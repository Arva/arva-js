<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/utils/view/RenderableHelper.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-styles.css">
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/DataBoundScrollView.js~DataBoundScrollView.html">DataBoundScrollView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/ReflowingScrollView.js~ReflowingScrollView.html">ReflowingScrollView</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/inputs</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/inputs/SingleLineTextInput.js~SingleLineTextInput.html">SingleLineTextInput</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/logic/branding</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/logic/branding/BrandingEngine.js~BrandingEngine.html">BrandingEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/logic/branding/BrandingEngineSingleton.js~BrandingEngineSingleton.html">BrandingEngineSingleton</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">core</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/App.js~App.html">App</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Controller.js~Controller.html">Controller</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Model.js~Model.html">Model</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Router.js~Router.html">Router</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/View.js~View.html">View</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">data</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/DataSource.js~DataSource.html">DataSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/PrioritisedArray.js~PrioritisedArray.html">PrioritisedArray</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/PrioritisedObject.js~PrioritisedObject.html">PrioritisedObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/Snapshot.js~Snapshot.html">Snapshot</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">data/datasources</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/datasources/FirebaseDataSource.js~FirebaseDataSource.html">FirebaseDataSource</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/datasources/SharePointDataSource.js~SharePointDataSource.html">SharePointDataSource</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">data/datasources/SharePoint</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/datasources/SharePoint/DataModelGenerator.js~DataModelGenerator.html">DataModelGenerator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/datasources/SharePoint/SharePointSnapshot.js~SharePointSnapshot.html">SharePointSnapshot</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">data/datasources/SharePoint/SPSoapAdapter</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/datasources/SharePoint/SPSoapAdapter/Settings.js~Settings.html">Settings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/datasources/SharePoint/SPSoapAdapter/SharePoint.js~SharePoint.html">SharePoint</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">data/datasources/SharePoint/SPSoapAdapter/Worker</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/datasources/SharePoint/SPSoapAdapter/Worker/SharePointClient.js~SharePointClient.html">SharePointClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/datasources/SharePoint/SPSoapAdapter/Worker/SoapClient.js~SoapClient.html">SoapClient</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">data/local</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/local/LocalModel.js~LocalModel.html">LocalModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/local/LocalPrioritisedArray.js~LocalPrioritisedArray.html">LocalPrioritisedArray</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">layout</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-event._subscribe">event._subscribe</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-event.on">event.on</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-event.once">event.once</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-event.pipe">event.pipe</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout._dockTo">layout._dockTo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.align">layout.align</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.animate">layout.animate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.clip">layout.clip</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.custom">layout.custom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.dock.bottom">layout.dock.bottom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.dock.fill">layout.dock.fill</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.dock.left">layout.dock.left</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.dock.none">layout.dock.none</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.dock.right">layout.dock.right</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.dock.top">layout.dock.top</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.dockPadding">layout.dockPadding</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.dockSpace">layout.dockSpace</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.draggable">layout.draggable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.flow">layout.flow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.fullSize">layout.fullSize</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.left">layout.left</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.opacity">layout.opacity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.origin">layout.origin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.renderable">layout.renderable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.rotate">layout.rotate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.rotateFrom">layout.rotateFrom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.scale">layout.scale</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.scrollable">layout.scrollable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.size">layout.size</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.skew">layout.skew</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.swipable">layout.swipable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.translate">layout.translate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-layout.translateFrom">layout.translateFrom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-TrueSizedLayoutDockHelper">TrueSizedLayoutDockHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-event">event</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-flow">flow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-layout">layout</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-flowStates">flowStates</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">routers</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/routers/ArvaRouter.js~ArvaRouter.html">ArvaRouter</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/BlobHelper.js~BlobHelper.html">BlobHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/DialogManager.js~DialogManager.html">DialogManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/Injection.js~Injection.html">Injection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/KeyboardHelper.js~KeyboardHelper.html">KeyboardHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/ObjectHelper.js~ObjectHelper.html">ObjectHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/Throttler.js~Throttler.html">Throttler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-callbackToPromise">callbackToPromise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-successAndErrorToPromise">successAndErrorToPromise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-waitMilliseconds">waitMilliseconds</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-combineOptions">combineOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-limit">limit</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils/di</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/di/Decorators.js~ClassProvider.html">ClassProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/di/Decorators.js~FactoryProvider.html">FactoryProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/di/Decorators.js~Inject.html">Inject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/di/Decorators.js~Provide.html">Provide</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/di/Decorators.js~SuperConstructor.html">SuperConstructor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/di/Decorators.js~TransientScope.html">TransientScope</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/di/injector.js~Injector.html">Injector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-annotate">annotate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hasAnnotation">hasAnnotation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-inject">inject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-provide">provide</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-readAnnotations">readAnnotations</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createProviderFromFnOrClass">createProviderFromFnOrClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isFunction">isFunction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isObject">isObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isUpperCase">isUpperCase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-toString">toString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ownKeys">ownKeys</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils/request</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ExistsRequest">ExistsRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-GetRequest">GetRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-PostRequest">PostRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-UrlParser">UrlParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ParseStringToXml">ParseStringToXml</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils/view</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/LayoutHelpers.js~BaseLayoutHelper.html">BaseLayoutHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/LayoutHelpers.js~DockedLayoutHelper.html">DockedLayoutHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/LayoutHelpers.js~FullSizeLayoutHelper.html">FullSizeLayoutHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/LayoutHelpers.js~TraditionalLayoutHelper.html">TraditionalLayoutHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/RenderableHelper.js~RenderableHelper.html">RenderableHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/SizeResolver.js~SizeResolver.html">SizeResolver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/Utils.js~Utils.html">Utils</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/utils/view/RenderableHelper.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Created by lundfall on 02/09/16.
 */

import OrderedHashMap               from &apos;ordered-hashmap&apos;;

import Transitionable               from &apos;famous/transitions/Transitionable.js&apos;;
import Easing                       from &apos;famous/transitions/Easing.js&apos;;
import Draggable                    from &apos;famous/modifiers/Draggable.js&apos;;
import ContainerSurface             from &apos;famous/Surfaces/ContainerSurface.js&apos;;
import Transform                    from &apos;famous/core/Transform.js&apos;;
import Timer                        from &apos;famous/utilities/Timer.js&apos;;
import GenericSync                  from &apos;famous/inputs/GenericSync.js&apos;;
import MouseSync                    from &apos;famous/inputs/MouseSync.js&apos;;
import TouchSync                    from &apos;famous/inputs/TouchSync.js&apos;;
import RenderNode                   from &apos;famous/core/RenderNode&apos;;
import Modifier                     from &apos;famous/core/Modifier.js&apos;;
import AnimationController          from &apos;famous-flex/AnimationController.js&apos;;

import {Throttler}                  from &apos;arva-js/utils/Throttler.js&apos;;

import {limit}                      from &apos;../Limiter.js&apos;;
import {Utils}                      from &apos;./Utils.js&apos;;
import {
    callbackToPromise,
    waitMilliseconds
}                                   from &apos;../CallbackHelpers.js&apos;;


export class RenderableHelper {

    /**
     * Creates a utility for maintaining proper state of decorated renderables
     * @param {Function} bindMethod
     * @param {Function} pipeMethod
     * @param {Object|Renderable} outputRenderables
     * @param sizeResolver
     */
    constructor(bindMethod, pipeMethod, outputRenderables, sizeResolver) {
        this._bindMethod = bindMethod;
        this._renderableCounterparts = outputRenderables;
        this._sizeResolver = sizeResolver;
        this._pipeToView = pipeMethod;
        this.waitingAnimations = [];
        this._renderables = {};
        this._groupedRenderables = {};
        this._pipedRenderables = {};
        this._groupedRenderables = {};
        this._runningFlowStates = {};
    }

    assignRenderable(renderable, renderableName) {
        this._renderables[renderableName] = renderable;
        let renderableEquivalent = this._addDecoratedRenderable(renderable, renderableName);
        this._renderableCounterparts[renderableName] = renderableEquivalent;
        this._setupAllRenderableListeners(renderableName);
    }

    /**
     * Setups all renderable listeners (decoration events, decoration pipes, pipe to the view)
     * @param {String} renderableName the name of the renderable
     * @param {Boolean} enabled set to false to unset all the events
     * @private
     */
    _setupAllRenderableListeners(renderableName, enabled = true) {
        /* If the this._renderableCounterparts equivalent doesn&apos;t have the pipe function as is the case with the draggable, then use the regular renderable */
        let renderableOrEquivalent = this._getPipeableRenderableFromName(renderableName);
        if (enabled) {
            this._pipeRenderable(renderableOrEquivalent, renderableName);
        } else {
            this._unpipeRenderable(renderableOrEquivalent, renderableName);
        }
        let {decorations} = this._renderables[renderableName];
        if (decorations) {
            this._setDecorationPipes(renderableOrEquivalent, decorations.pipes, enabled);
            this._setDecorationEvents(renderableOrEquivalent, decorations.eventSubscriptions, enabled);
        }
    }

    /**
     * Sets the decoration events that are specified with (among potential others) @layout.on and @layout.once
     * @param {String} renderableName
     * @param enable. If false, removes the events.
     * @private
     */
    _setDecorationEvents(renderable, subscriptions, enable = true) {
        for (let subscription of subscriptions || []) {
            let subscriptionType = subscription.type || &apos;on&apos;;
            if (!enable) {
                /* In famous, you remove a listener by calling removeListener, but some classes might have another event
                 * listener that is called off
                 */
                subscriptionType = renderable.removeListener ? &apos;removeListener&apos; : &apos;off&apos;;
            }
            let eventName = subscription.eventName;
            let callback = subscription.callback;
            if (subscriptionType in renderable) {
                renderable[subscriptionType](eventName, this._bindMethod(callback));
            }
        }
    }
    
    /**
     * Pipes the renderable to a list of other renderables
     * @param {Renderable} renderable
     * @param {Array|String} Names of renderables that have to be piped.
     * @param {Boolean} enabled. Set to false to unpipe
     * @private
     */
    _setDecorationPipes(renderable, pipes, enabled = true) {
        for (let pipeToName of pipes || []) {
            let target = pipeToName ? this._renderables[pipeToName] : this;
            let pipeFn = (enabled ? &apos;&apos; : &apos;un&apos;) + &apos;pipe&apos;;
            /* In order to keep things consistent and easier to use, we pipe from the renderable equivalent */
            if (renderable[pipeFn]) {
                renderable[pipeFn](target);
            }
            if (renderable[pipeFn] &amp;&amp; target._eventOutput) {
                renderable[pipeFn](target._eventOutput);
            }
        }

    }

    /**
     * Unpipes a renderables that has been piped to this view
     * @param {String} renderableName The name of the renderable
     * @private
     */
    _unpipeRenderable(renderableName) {
        if(this._pipeToView(this._pipedRenderables[renderableName]), false){
            delete this._pipedRenderables[renderableName];
        }
    }

    /**
     * Pipes a renderable to this view
     * @param {Renderable} renderable. The renderable that is going to be piped
     * @param {String} renderableName. The name of the renderable that is going to be piped.
     * @private
     */
    _pipeRenderable(renderable, renderableName) {
        /* Auto pipe events from the renderable to the view */
        if(this._pipeToView(renderable, true)){
            this._pipedRenderables[renderableName] = renderable;
        }
    }

    /**
     * Determines whether the renderable counterpart (i.e. animationcontroller or containersurface) should be used 
     * when piping, or the renderable itself
     * @param {String} renderableName The name of the renderable
     * @returns {Renderable} the renderable or its counterpart
     * @private
     */
    _getPipeableRenderableFromName(renderableName) {
        return this._renderableCounterparts[renderableName].pipe ? this._renderableCounterparts[renderableName] : this._renderables[renderableName];
    }

    /**
     * Adds a decorated renderable to the bookkeeping of the view
     * @param renderable
     * @param renderableName
     * @returns {Renderable} newRenderable The renderable that is normally stored this._renderableCounterpart[renderableName]
     * @private
     */
    _addDecoratedRenderable(renderable, renderableName) {
        let {flow, size, dock} = renderable.decorations;

        if (size) {
            this._bindSizeFunctions(size);
        }
        if (dock &amp;&amp; dock.size) {
            this._bindSizeFunctions(dock.size);
        }
        let renderableCounterpart = this._processsDecoratedRenderableCounterpart(renderable, renderableName);

        this._addRenderableToDecoratorGroup(renderable, renderableCounterpart, renderableName);
        return renderableCounterpart;
    }

    /**
     * Bind the size functions so that they don&apos;t have to be bound afterwards
     * @param {Array|Number} size
     * @private
     */
    _bindSizeFunctions(size) {
        for (let index = 0; index &lt; 2; index++) {
            if (typeof size[index] === &apos;function&apos;) {
                size[index] = this._bindMethod(size[index]);
            }
        }
    }

    /**
     * Returns true if there are any flowy renderables.
     * @returns {Boolean} hasFlowyRenderables
     */
    hasFlowyRenderables() {
        for (let groupName in this._groupedRenderables) {
            let renderableGroup = this._groupedRenderables[groupName];
            if (!renderableGroup.keys().every((renderableName) =&gt; !renderableGroup.get(renderableName)[0].decorations.flow)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Processes the renderable counter-part of the renderable. The counterpart is different from the renderable
     * in @layout.draggable, @layout.swipable, @layout.animate, and others.
     * @param {Renderable} renderable the renderable which has renderable.decorations set to determine the counter part
     * @param {String} renderableName the name of the renderable
     * @returns {AnimationController|ContainerSurface|RenderNode|*} The renderable counterpart
     * @private
     */
    _processsDecoratedRenderableCounterpart(renderable, renderableName) {
        let {draggableOptions, swipableOptions, clip, animation, flow} = renderable.decorations;

        /* If we clip, then we need to create a containerSurface */
        if (clip) {
            let clipSize = clip.size;
            /* Resolve clipSize specified as undefined */
            let containerSurface = new ContainerSurface({
                size: clipSize,
                properties: {overflow: &apos;hidden&apos;, ...clip.properties}
            });
            containerSurface.add(renderable);
            if (containerSurface.pipe) {
                containerSurface.pipe(renderable._eventOutput);
            }
            renderable.containerSurface = containerSurface;
        }

        if (animation) {
            this._processAnimatedRenderable(renderable, renderableName, animation);
        }

        if (swipableOptions) {
            renderable = this._initSwipable(swipableOptions, renderable);
        } else if (draggableOptions &amp;&amp; !renderable.node) {
            renderable.node = new RenderNode();
            let draggable = new Draggable(draggableOptions);
            renderable.draggable = draggable;
            renderable.node.add(draggable).add(renderable);
            renderable.pipe(draggable);
            //TODO: We don&apos;t do an unpiping of the draggable, which might be dangerous
            this._pipeToView(draggable);
        }

        if (renderable.node) {
            /* Assign output handler */
            renderable.node._eventOutput = renderable._eventOutput;
        }

        let renderableCounterpart = renderable.animationController || renderable.containerSurface || renderable.node || renderable;
        /* If a renderable has an AnimationController used to animate it, add that to this._renderableCounterparts.
         * If a renderable has an ContainerSurface used to clip it, add that to this._renderableCounterparts.
         * this._renderableCounterparts is used in the LayoutController in this.layout to render this view. */
        if (flow) {
            renderableCounterpart.isFlowy = true;
        }
        return renderableCounterpart;
    }

    /**
     * Pipes the output events of all items in the renderable counterparts that might have been forgotten due to legacy way of declaring
     * renderables
     * @returns {void}
     * @private
     */
    pipeAllRenderables() {
        for (let renderableName in this.renderables) {
            if (!this._pipedRenderables[renderableName]) {
                this._pipeRenderable(this._getPipeableRenderableFromName(renderableName), renderableName);
            }
        }
    }

    /**
     * Initialize all animation set by @layout.animate
     */
    initializeAnimations() {
        for (let animation of (this.waitingAnimations || [])) {
            let renderableToWaitFor = this._renderables[animation.waitFor];
            if (renderableToWaitFor &amp;&amp; renderableToWaitFor.on) {
                renderableToWaitFor.on(&apos;shown&apos;, function subscription() {
                    animation.showMethod();
                    if (&apos;off&apos; in renderableToWaitFor) {
                        renderableToWaitFor.off(&apos;shown&apos;, subscription);
                    }
                    if (&apos;removeListener&apos; in renderableToWaitFor) {
                        renderableToWaitFor.removeListener(&apos;shown&apos;, subscription);
                    }
                });
            } else {
                Utils.warn(`Attempted to delay showing renderable ${animation.waitFor}, which does not exist or contain an on() method.`);
            }
        }
    }
    
    //Done
    /**
     * Processes an animated renderable
     * @param renderable
     * @param renderableName
     * @param options
     * @private
     */
    _processAnimatedRenderable(renderable, renderableName, options) {

        let pipeRenderable = () =&gt; {
            if (renderable.pipe) renderable.pipe(renderable.animationController._eventOutput)
        };

        /* If there&apos;s already an animationcontroller present, just change the options */
        let renderableCounterpart = this._renderableCounterparts[renderableName];
        if (renderableCounterpart instanceof AnimationController) {
            renderable.animationController = renderableCounterpart;
            renderable.animationController.setOptions(options);
            pipeRenderable();
        } else {
            let animationController = renderable.animationController = new AnimationController(options);
            pipeRenderable();
            let showMethod = this.showWithAnimationController.bind(this, animationController, renderable);

            if (options.delay &amp;&amp; options.delay &gt; 0 &amp;&amp; options.showInitially) {
                Timer.setTimeout(showMethod, options.delay);
            } else if (options.waitFor) {
                this.waitingAnimations.push({showMethod: showMethod, waitFor: options.waitFor});
            } else if (options.showInitially) {
                showMethod();
            }


        }
    }
    //Done
    /**
     * Shows a renderable using the animationController specified. When operation is complete, the renderable emits
     * the one events &apos;show&apos; or &apos;hide&apos;, depending on what operation that was done.
     * @param animationController
     * @param renderable
     * @param show
     * @private
     */
    showWithAnimationController(animationController, renderable, show = true, callback) {
        animationController._showingRenderable = show;
        let callbackIfExists = () =&gt; {
            if(callback) {
                callback();
            }
        };
        let emitOnFinished = () =&gt; {
            if (renderable.emit) {
                renderable.emit(show ? &apos;shown&apos; : &apos;hidden&apos;);
            }
            callbackIfExists();
        };

        if (show) {
            animationController.show(renderable.containerSurface || renderable, null, emitOnFinished);
        } else {
            animationController.hide(null, emitOnFinished);
        }
    }
    //Done
    _addRenderableToDecoratorGroup(renderable, renderableCounterpart, renderableName) {
        /* Group the renderable */
        let groupName = this._getGroupName(renderable);

        if (groupName) {
            if (!(groupName in this._groupedRenderables)) {
                this._groupedRenderables[groupName] = new OrderedHashMap();
            }
            /* We save the both the renderable and the renderable counterpart in pairs */
            this._groupedRenderables[groupName].set(renderableName, [renderable, renderableCounterpart]);
        }
    }

    //Done
    _getGroupName(renderable) {
        let {decorations} = renderable;

        if (!!decorations.dock) {
            /* &apos;filled&apos; is a special subset of &apos;docked&apos; renderables, that need to be rendered after the normal &apos;docked&apos; renderables are rendered. */
            return decorations.dock.dockMethod === &apos;fill&apos; ? &apos;filled&apos; : &apos;docked&apos;;
        } else if (!!decorations.fullSize) {
            return &apos;fullSize&apos;;
        } else if (decorations.size || decorations.origin || decorations.align || decorations.translate) {
            return &apos;traditional&apos;;
        } else {
            /* This occurs e.g. when a renderable is only marked @renderable, and its parent view has a @layout.custom decorator to define its context. */
            return &apos;ignored&apos;;
        }
    }

    /**
     * Gets the renderables of a certain group
     * @param {String} The name of the group
     * @returns {OrderedHashMap} A map containing Array-pairs of [renderable, renderableCounterpart] containing the renderables of the specified type.
     */
    getRenderableGroup(groupName) {
        return this._groupedRenderables[groupName];
    }
    //Done
    /**
     * Removes the renderable from the view
     * @param {String} renderableName The name of the renderable
     */
    removeRenderable(renderableName) {
        let renderable = this._renderables[renderableName];
        this._setDecorationPipes(renderableName, false);
        this._setDecorationEvents(renderableName, false);
        this._unpipeRenderable(renderableName, renderableName);
        this._removeRenderableFromDecoratorGroup(renderable, renderableName);
        delete this._renderableCounterparts[renderableName];
        delete this._renderables[renderableName];
    }
    //Done
    _removeRenderableFromDecoratorGroup(renderable, renderableName) {
        let groupName = this._getGroupName(renderable);
        this._removeRenderableFromGroupWithName(renderableName, groupName);
    }
    //Done
    _removeRenderableFromGroupWithName(renderableName, groupName) {
        let group = this._groupedRenderables[groupName];
        group.remove(renderableName);
        if (!group.count()) {
            delete this._groupedRenderables[groupName];
        }
    }
    //done
    /**
     * @example
     * decorateRenderable(&apos;myRenderable&apos;,layout.size(100, 100));
     *
     * Decorates a renderable with other decorators. Using the same decorators as used previously will override the old ones.
     * @param {String} renderableName The name of the renderable
     * @param ...decorators The decorators that should be applied
     */
    decorateRenderable(renderableName, ...decorators) {
        let renderable = this._renderables[renderableName];
        /* Add translate and rotate to be sure that there decorators translateFrom and rotateFrom work */
        let fakeRenderable = {
            decorations: {
                translate: renderable.decorations.translate || [0, 0, 0],
                rotate: renderable.decorations.rotate || [0, 0, 0]
            }
        };
        if (!decorators.length) {
            Utils.warn(&apos;No decorators specified to decorateRenderable(renderableName, ...decorators)&apos;);
        }
        /* There can be existing decorators already, which are preserved. We are extending the decorators object,
         * by first creating a fake renderable that gets decorators */
        this.applyDecoratorFunctionsToRenderable(fakeRenderable, decorators)
        let {decorations} = fakeRenderable;
        let renderableOrEquivalent = this._getPipeableRenderableFromName(renderableName);
        /* We might need to do extra piping */
        this._setDecorationPipes(renderableOrEquivalent, decorations.pipes);
        this._setDecorationEvents(renderableOrEquivalent, decorations.eventSubscriptions);

        /* If the renderable is surface, we need to do some special things if there is a true size being used */
        if (Utils.renderableIsSurface(renderable)) {
            let sizesToCheck = [];
            let {size, dock} = decorations;
            if (size) {
                sizesToCheck.push(size);
            }
            if (dock) {
                sizesToCheck.push(dock.size);
            }
            let renderableSize = [undefined, undefined];
            let trueSizedInfo = this._sizeResolver.getSurfaceTrueSizedInfo(renderable);
            for (let sizeToCheck of sizesToCheck) {
                for (let dimension of [0, 1]) {
                    if (this._sizeResolver.isValueTrueSized(sizeToCheck[dimension])) {
                        if (!trueSizedInfo) {
                            trueSizedInfo = this._sizeResolver.configureTrueSizedSurface(renderable);
                        }
                        trueSizedInfo.trueSizedDimensions[dimension] = true;
                        renderableSize[dimension] = true;
                    } else {
                        if (trueSizedInfo) {
                            trueSizedInfo.trueSizedDimensions[dimension] = false;
                        }
                    }
                }
            }
            if (sizesToCheck.length) {
                renderable.setSize(renderableSize);
            }
        }
        let oldRenderableGroupName = this._getGroupName(renderable);
        let shouldDisableDock = (fakeRenderable.decorations.disableDock &amp;&amp; renderable.decorations.dock);
        let shouldDisableFullSize = (fakeRenderable.decorations.size &amp;&amp; renderable.decorations.fullSize);
        if (shouldDisableDock) {
            delete renderable.decorations.dock;
        }
        if (shouldDisableFullSize) {
            delete renderable.decorations.fullSize;
        }
        /* Extend the object */
        Object.assign(renderable.decorations, fakeRenderable.decorations);
        /* See if we have to redo the grouping */
        let needToChangeDecoratorGroup = (oldRenderableGroupName !== this._getGroupName(renderable)) || shouldDisableDock || shouldDisableFullSize;
        /* Process new renderable equivalent, if that applies */
        let renderableCounterpart = this._renderableCounterparts[renderableName] = this._processsDecoratedRenderableCounterpart(renderable, renderableName);
        if (needToChangeDecoratorGroup) {
            this._removeRenderableFromGroupWithName(renderableName, oldRenderableGroupName);
            this._addRenderableToDecoratorGroup(renderable, renderableCounterpart, renderableName);
        }

    }
    //done
    applyDecoratorFunctionsToRenderable(renderable, decorators){
        for (let decorator of decorators) {
            /* There can be existing decorators already, which are preserved. We are extending the decorators object,
             * by first creating a fake renderable that gets decorators */
            decorator(renderable);
        }
    }
    //Done
    replaceRenderable(renderableName, newRenderable) {
        let renderable = this._renderables[renderableName];
        let renderableHasAnimationController = (this._renderableCounterparts[renderableName] instanceof AnimationController);
        /* If there isn&apos;t a renderable equivalent animationController that does the piping, then we need to redo the event piping */
        if (!renderableHasAnimationController) {
            this._setupAllRenderableListeners(renderableName, false);
        }
        newRenderable.decorations = {...newRenderable.decorations, ...renderable.decorations};
        let newRenderableCounterpart = this._processsDecoratedRenderableCounterpart(newRenderable, renderableName);
        this._groupedRenderables[this._getGroupName(renderable)].set(renderableName, [newRenderable, newRenderableCounterpart]);
        if (!renderableHasAnimationController) {
            this._renderableCounterparts[renderableName] = newRenderableCounterpart;
            this._setupAllRenderableListeners(renderableName, true);
        }
        this._renderables[renderableName] = newRenderable;
    }


    //Done
    async setRenderableFlowState(renderableName = &apos;&apos;, stateName = &apos;&apos;) {

        let renderable = this._renderables[renderableName];
        if (!renderable || !renderable.decorations || !renderable.decorations.flow) {
            return Utils.warn(`setRenderableFlowState called on non-existing or renderable &apos;${renderableName}&apos; without flowstate`);
        }
        let flowOptions = renderable.decorations.flow;

        /* Keep track of which flow state changes are running. We only allow one at a time per renderable.
         * The latest one is always the valid one.
         */
        let flowWasInterrupted = false;

        flowOptions.currentState = stateName;
        for (let {transformations, options} of flowOptions.states[stateName].steps) {
            flowOptions.currentTransition = options.transition;
            this.decorateRenderable(renderableName, ...transformations);

            /* Make sure FlowLayoutNode.set() is called next render tick */
            this._sizeResolver.requestReflow();

            /* Set the callback of the renderable so it&apos;s passed to the flowLayoutNode */
            let resolveData = await new Promise((resolve) =&gt; renderable.decorations.flow.callback = resolve);

            /* Optionally, we insert a delay in between ending the previous state change, and starting on the new one. */
            if (options.delay) {
                await waitMilliseconds(options.delay);
            }

            /* If the flow has been interrupted */
            if (resolveData.reason === &apos;flowInterrupted&apos;) {
                flowWasInterrupted = true;
                break;
            }


            let emit = (renderable._eventOutput &amp;&amp; renderable._eventOutput.emit || renderable.emit).bind(renderable._eventOutput || renderable);
            emit(&apos;flowStep&apos;, {state: stateName});
        }

        return !flowWasInterrupted;
    }
    //Done
    async setViewFlowState(stateName = &apos;&apos;, flowOptions) {
        let steps = flowOptions.viewStates[stateName];

        /* This is intended to be overwritten by other asynchronous calls to this method, see the stateName check below. */
        flowOptions.currentState = stateName;

        for (let step of steps) {
            await Promise.all(this.generateWaitQueueFromViewStateStep(step));

            /* If another state has been set since the invocation of this method, skip any remaining transformations. */
            if (flowOptions.currentState !== stateName) {
                break;
            }
        }

        return true;
    }

    generateWaitQueueFromViewStateStep(step) {
        let waitQueue = [];
        for (let renderableName in step) {
            let state = step[renderableName];
            waitQueue.push(this.setRenderableFlowState(renderableName, state));
        }
        return waitQueue;
    }


    getRenderableFlowState(renderableName = &apos;&apos;) {
        let renderable = this._renderables[renderableName];
        if (!renderable || !renderable.decorations || !renderable.decorations.flow) {
            return Utils.warn(`getRenderableFlowState called on non-existing or renderable &apos;${renderableName}&apos; without flowstate`);
        }
        let flowOptions = renderable.decorations.flow;
        return flowOptions.currentState;
    }

    getViewFlowState(flowOptions = {}) {
        return flowOptions.currentState;
    }

    /**
     * Create the swipable and register all the event logic for a swipable renderable
     * @private
     */
    _initSwipable(swipableOptions = {}, renderable = {}) {
        GenericSync.register({
            &apos;mouse&apos;: MouseSync,
            &apos;touch&apos;: TouchSync
        });

        let sync = new GenericSync({
            &apos;mouse&apos;: {},
            &apos;touch&apos;: {}
        });

        renderable.pipe(sync);

        /* Translation modifier */
        var positionModifier = new Modifier({
            transform: function () {
                let [x, y] = position.get();
                return Transform.translate(x, y, 0);
            }
        });

        var position = new Transitionable([0, 0]);

        sync.on(&apos;update&apos;, (data)=&gt; {
            let [x,y] = position.get();
            x += !swipableOptions.snapX ? data.delta[0] : 0;
            y += !swipableOptions.snapY ? data.delta[1] : 0;
            let {yRange = [0, 0], xRange = [0, 0]} = swipableOptions;
            y = limit(yRange[0], y, yRange[1]);
            x = limit(xRange[0], x, xRange[1]);
            position.set([x, y]);
        });

        sync.on(&apos;end&apos;, (data)=&gt; {
            let [x,y] = position.get();
            data.velocity[0] = Math.abs(data.velocity[0]) &lt; 0.5 ? data.velocity[0] * 2 : data.velocity[0];
            let endX = swipableOptions.snapX ? 0 : x + data.delta[0] + (data.velocity[0] * 175);
            let endY = swipableOptions.snapY ? 0 : y + data.delta[1] + (data.velocity[1] * 175);
            let {yRange = [0, 0], xRange = [0, 0]} = swipableOptions;
            endY = limit(yRange[0], endY, yRange[1]);
            endX = limit(xRange[0], endX, xRange[1]);
            position.set([endX, endY], {
                curve: Easing.outCirc,
                duration: (750 - Math.abs((data.velocity[0] * 150)))
            });

            this._determineSwipeEvents(renderable, swipableOptions, endX, endY);

        });

        renderable.node = new RenderNode();
        renderable.node.add(positionModifier).add(renderable);

        return renderable;
    }
    
    _determineSwipeEvents(renderable, swipableOptions = {}, endX = 0, endY = 0) {

        if (!renderable || !renderable._eventOutput) return;

        let xThreshold = swipableOptions.xThreshold || [undefined, undefined];
        let yThreshold = swipableOptions.yThreshold || [undefined, undefined];

        if (xThreshold[1] &amp;&amp; endX &gt; xThreshold[1]) {
            renderable._eventOutput.emit(&apos;swiped&apos;, {
                direction: 0,
                displacement: &apos;right&apos;
            });
        }

        if (xThreshold[0] &amp;&amp; endX &lt; xThreshold[0]) {
            renderable._eventOutput.emit(&apos;swiped&apos;, {
                direction: 0,
                displacement: &apos;left&apos;
            });
        }

        if (yThreshold[1] &amp;&amp; endY &gt; yThreshold[1]) {
            renderable._eventOutput.emit(&apos;swiped&apos;, {
                direction: 1,
                displacement: &apos;bottom&apos;
            });
        }

        if (yThreshold[0] &amp;&amp; endY &lt; yThreshold[0]) {
            renderable._eventOutput.emit(&apos;swiped&apos;, {
                direction: 1,
                displacement: &apos;top&apos;
            });
        }
    }

    /**
     * Rearranges the order in which docked renderables are parsed for rendering, ensuring that &apos;renderableName&apos; is processed
     * before &apos;nextRenderableName&apos;.
     * @param {String} renderableName
     * @param {String} nextRenderableName
     */
    prioritiseDockBefore(renderableName, nextRenderableName) {
        let dockedRenderables = this._groupedRenderables.docked;
        if (!dockedRenderables) {
            Utils.warn(`Could not prioritise &apos;${renderableName}&apos; before &apos;${nextRenderableName}&apos;: no docked renderables present.`);
            return false;
        }
        let result = this._prioritiseDockAtIndex(renderableName, dockedRenderables.indexOf(nextRenderableName));
        if (!result) {
            Utils.warn(`Could not prioritise &apos;${renderableName}&apos; before &apos;${nextRenderableName}&apos;: could not find one of the renderables by name.
                        The following docked renderables are present: ${dockedRenderables.keys()}`);
        }
        return result;
    }

    /**
     * @param {String} renderableName
     * @param {String} prevRenderableName
     */
    prioritiseDockAfter(renderableName, prevRenderableName) {
        let dockedRenderables = this._groupedRenderables.docked;
        if (!dockedRenderables) {
            Utils.warn(`Could not prioritise &apos;${renderableName}&apos; after &apos;${prevRenderableName}&apos;: no docked renderables present.`);
            return false;
        }
        let result = this._prioritiseDockAtIndex(renderableName, dockedRenderables.indexOf(prevRenderableName) + 1);
        if (!result) {
            Utils.warn(`Could not prioritise &apos;${renderableName}&apos; after &apos;${prevRenderableName}&apos;: could not find one of the renderables by name.
                        The following docked renderables are present: ${dockedRenderables.keys()}`);
        }
        return result;
    }

    /**
     * Helper function used by prioritiseDockBefore and prioritiseDockAfter to change order of docked renderables
     * @param renderableName
     * @param index
     * @returns {boolean}
     * @private
     */
    _prioritiseDockAtIndex(renderableName, index) {
        let dockedRenderables = this._groupedRenderables.docked;
        let renderableToRearrange = dockedRenderables.get(renderableName);

        if (index &lt; 0 || !renderableToRearrange) {
            return false;
        }

        dockedRenderables.remove(renderableName);
        dockedRenderables.insert(index, renderableName, renderableToRearrange);
        
        return true;

    }
    
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.0-alpha)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
