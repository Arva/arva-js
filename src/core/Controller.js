/**


 @author: Hans van den Akker (mysim1)
 @license NPOSL-3.0
 @copyright Bizboard, 2015

 */

import _                        from 'lodash';
import EventEmitter             from 'eventemitter3';
import AnimationController      from 'famous-flex/AnimationController.js';

import {inject}                 from 'di';

import {Router}                 from './Router.js';
import {ObjectHelper}           from '../utils/ObjectHelper.js';


/**
 * The Controller class provides the highest level of control regarding the application features. Within the Controller context
 * each method will registered to receive calls from the Routing engine. With direct access to the Famo.us Context, every method can
 * control the creation of Views and Transitions.
 */
@inject(Router, AnimationController)
export class Controller extends EventEmitter {

    constructor(router, context, spec) {
        super();
        this.spec = spec;
        this.router = router;
        this.context = context;



        ObjectHelper.bindAllMethods(this, this);


        // add the controller route to the router
        var routeName = Object.getPrototypeOf(this).constructor.name.replace('Controller', '');
        routeName += '/:method';

        // handle router url changes and execute the appropiate controller method
        this.router.add(routeName, this.onRouteCalled, this);
    }

    /**
     * Called by the Router when this controller instance is being navigated to. Calls the controller's method in the given route,
     * and triggers a famous-flex AnimationController show() with the View instance that the method returns. Is also capable of receiving
     * a Promise from the method, in which case the show() is called after the promise is resolved.
     * @param {Object} route Route object generated by the Router. Contains a method name to call, and a render spec for passing to the AnimationController.
     * @returns {Boolean} success Whether the controller method was fully executed, and the Router should emit a routechange event.
     */
    onRouteCalled(route) {
        if (typeof this[route.method] === 'function') {
            var result = this[route.method].apply(this, route.values);

            if (result) {
                this.emit('renderstart', route.method);

                if (result instanceof Promise) { // we can assume the method called was asynchronous from nature, therefore we await the result

                    result.then((delegatedresult) => {
                        // assemble a callback based on the execution scope and have that called when rendering is completed
                        this.context.show(delegatedresult, _.extend(route.spec, this.spec), () => {
                            this.emit('renderend', route.method);
                        });
                        this.emit('rendering', route.method);
                    });
                } else {

                    // assemble a callback based on the execution scope and have that called when rendering is completed
                    this.context.show(result, _.extend(route.spec, this.spec), () => {
                        this.emit('renderend', route.method);
                    });
                    this.emit('rendering', route.method);
                }
                // assemble a callback based on the execution scope and have that called when rendering is completed
                this.context.show(result, _.extend(route.spec, this.spec), function(){ this.emit('renderend', route.method); }.bind(this));
                this.emit('rendering', route.method);

                return true;
            } else {
                return false;
            }
        } else {
            console.log('Route does not exist!');
            return false;
        }
    }
}
