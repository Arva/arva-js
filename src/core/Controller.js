/**
 This Source Code is licensed under the MIT license. If a copy of the
 MIT-license was not distributed with this file, You can obtain one at:
 http://opensource.org/licenses/mit-license.html.

 @author: Hans van den Akker (mysim1)
 @license MIT
 @copyright Bizboard, 2015

 */

import _                    from 'lodash';
import {Inject}             from 'di';
import {Router}             from './Router.js';
import {ObjectHelper}       from 'arva-utils/ObjectHelper.js';
import EventHandler         from 'famous/core/EventHandler.js';
import AnimationController  from 'famous-flex/src/AnimationController.js';


/**
 * The Controller class provides the highest level of control regarding the application features. Within the Controller context
 * each method will registered to receive calls from the Routing engine. With direct access to the Famo.us Context, every method can
 * control the creation of Views and Transitions.
 */
@Inject(Router, AnimationController)
export class Controller {

    constructor(router, context, spec) {
        //super();
        this.spec = spec;
        this.router = router;
        this.context = context;
        this._eventOutput = new EventHandler();

        // register the controller object in the router
        //this.router.controllers.push(this);


        ObjectHelper.bindAllMethods(this, this);


        // add the controller route to the router
        var routeName = Object.getPrototypeOf(this).constructor.name.replace('Controller', '');
        routeName += '/:method';

        // handle router url changes and execute the appropiate controller method
        this.router.add(routeName, this.onRouteCalled);
    }

    /**
     * Adds an event handler for the given even type. Currently used event types are 'renderstart', 'rendering', and 'renderend'.
     * @param {String} event Event type to subscribe on.
     * @param {Function} handler Function to call when the given event type is emitted.
     * @return {void}
     */
    on(event, handler) {
        this._eventOutput.on(event, handler);
    }

    /**
     * Called by the Router when this controller instance is being navigated to. Calls the controller's method in the given route,
     * and triggers a famous-flex AnimationController show() with the View instance that the method returns. Is also capable of receiving
     * a Promise from the method, in which case the show() is called after the promise is resolved.
     * @param {Object} route Route object generated by the Router. Contains a method name to call, and a render spec for passing to the AnimationController.
     * @returns {Boolean} success Whether the controller method was fully executed, and the Router should emit a routechange event.
     */
    onRouteCalled(route) {
        if (typeof this[route.method] === 'function') {
            var result = this[route.method].apply(this, route.values);

            if (result) {
                this._eventOutput.emit('renderstart', route.method);

                if (result instanceof Promise) { // we can assume the method called was asynchronous from nature, therefore we await the result

                    result.then((delegatedresult) => {
                        // assemble a callback based on the execution scope and have that called when rendering is completed
                        this.context.show(delegatedresult, _.extend(route.spec, this.spec), () => {
                            this._eventOutput.emit('renderend', route.method);
                        });
                        this._eventOutput.emit('rendering', route.method);
                    });
                } else {

                    // assemble a callback based on the execution scope and have that called when rendering is completed
                    this.context.show(result, _.extend(route.spec, this.spec), () => {
                        this._eventOutput.emit('renderend', route.method);
                    });
                    this._eventOutput.emit('rendering', route.method);
                }
                // assemble a callback based on the execution scope and have that called when rendering is completed
                this.context.show(result, _.extend(route.spec, this.spec), function(){ this._eventOutput.emit('renderend', route.method); }.bind(this));
                this._eventOutput.emit('rendering', route.method);

                return true;
            } else {
                return false;
            }
        } else {
            console.log('Route does not exist!');
            return false;
        }
    }
}
