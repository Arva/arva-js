<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | Arva</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-styles.css"><meta name="description" content="this is awesome library"><meta property="og:type" content="website"><meta property="og:url" content="http://arva.io"><meta property="og:site_name" content="Arva"><meta property="og:title" content="Arva"><meta property="og:image" content="http://arva.io/img/logo-arva.png"><meta property="og:description" content="this is awesome library"><meta property="og:author" content="https://twitter.com/arvamazing"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Arva"><meta property="twitter:description" content="this is awesome library"><meta property="twitter:image" content="http://arva.io/img/logo-arva.png"></head>
<body class="layout-container manual-root" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Arva/arva-js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/tutorial.html"><a href="manual/tutorial.html#what--39-s-arva-js-" data-ice="link">What&apos;s Arva JS?</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/tutorial.html"><a href="manual/tutorial.html#layout-and-hierarchy" data-ice="link">Layout and hierarchy</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/tutorial.html"><a href="manual/tutorial.html#animations-and-states" data-ice="link">Animations and states</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/tutorial.html"><a href="manual/tutorial.html#data-binding-and-views" data-ice="link">Data binding and Views</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tutorial.html"><a href="manual/tutorial.html#two-way-data-binding" data-ice="link">Two-way data binding</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/tutorial.html"><a href="manual/tutorial.html#but-what-about-react-" data-ice="link">But what about React?</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tutorial.html"><a href="manual/tutorial.html#state-updates" data-ice="link">State updates</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/tutorial.html"><a href="manual/tutorial.html#layout-and-animation" data-ice="link">Layout and Animation</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/tutorial.html"><a href="manual/tutorial.html#the-bigger-picture" data-ice="link">The bigger picture</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/installation.html"><a href="manual/installation.html" data-ice="link">Getting started</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#prerequisites" data-ice="link">Prerequisites</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#installation" data-ice="link">Installation</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#on-we-go-" data-ice="link">On we go!</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/first-app.html"><a href="manual/first-app.html" data-ice="link">Writing your first application</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/first-app.html"><a href="manual/first-app.html#1--app-js" data-ice="link">1. App.js</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/first-app.html"><a href="manual/first-app.html#2--homecontroller-js" data-ice="link">2. HomeController.js</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/first-app.html"><a href="manual/first-app.html#3--homeview-js" data-ice="link">3. HomeView.js</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/first-app.html"><a href="manual/first-app.html#4--building-and-previewing" data-ice="link">4. Building and previewing</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown" data-ice="content"><h1 id="what--39-s-arva-js-">What&apos;s Arva JS?</h1><p>Arva is a fresh-cut framework for building interactive applications. <strong>Applications</strong> that are <strong>interactive</strong>
leverage complete built-in animation capabilities along with powerful state maintenance that successfully maintains UI interaction in a highly interactive and fluid way.
In other words, this is not only an <strong>animation library</strong> (GreenSock, Velocity.js etc), nor an <strong>application framework</strong> (React, Angular, etc), but a holistic solution of both.</p>
<p>Arva solves the problem of layout and animation without the need to bother with CSS nor HTML. While CSS is still used for <strong>styling</strong> of the content, whereas <strong>positioning</strong> and <strong>sizing</strong> is handled in a more pragmatic way.
Arva abstracts away some of the concerns that many front-end developers face,
which includes CSS deep-dives and directives like <code>display: inline-block</code> <code>margin:auto</code>, <code>position:relative</code>, <code>clear:left</code>, <code>float: right</code>, <code>zoom: 1</code> <code>overflow: auto</code>, <code>-webkit-box-sizing: border-box</code> and so on.</p>
<p>Even modern paradigms like <code>flexbox</code> won&apos;t be necessary anymore. In addition, Arva refrains from using any templating language, and only uses standard EcmaScript syntax. Let&apos;s get started.</p>
<h1 id="layout-and-hierarchy">Layout and hierarchy</h1><p>The API surface of Arva <a href="https://github.com/Arva/demo">layout</a> in much smaller than that of CSS. We have 11 available layout operators to be learned once, which can be combined with each other
to create powerful permutations of features.</p>
<p>And because an example is usually the best way to start out an explanation, we demonstrate how to construct the following layout.</p>
<p><img src="./manual/asset/layout.png" alt="layout-example =250x"></p>
<p>We see a top bar, a background color, and a bottom button, along with some box shadows to create a sense of depth in line with the current fashion of material design.</p>
<p>This is achieved with the following code.</p>
<pre><code><code class="source-code prettyprint">
export class RootView extends View {

    @layout
        /* Take up the full space*/
        .fullSize()
        /* -1 negative z-index to make space for the foreground content*/
        .translate(0, 0, -1)
        /* The surface is the most fundamental element to compose views with */
    background = Surface.with({properties: {backgroundColor: &apos;aliceblue&apos; }});


    @layout
        /* Docking makes something appear at the top with a height of 44 pixels */
        .dock.top(48)
    /* This is a top bar */
    topBar = TopBar.with({title: &apos;Dashboard&apos;})

    @layout
        /* Stick bottom right, and translate upwards/left for margin*/
        .stick.bottomRight()
        .translate(-16, -16, 0)
        .size(64, 64)
    bottomButton = Button.with()

}</code>
</code></pre><p>These definitions heavily make ES6 features <a href="https://github.com/tc39/proposal-class-fields">class fields</a> and <a href="https://github.com/tc39/proposal-decorators">decorators</a>.</p>
<p><a href="https://github.com/Arva/demo">Full source code can be found here under &apos;layout&apos;</a>
For API reference regarding layout, see the <a href="http://arva.io/arva-js/class/src/layout/Decorators.js~Layout.html">docs</a>.</p>
<p>As you can see, all decorators of the same type (<a href="http://localhost:63342/arva-js/docs/variable/index.html#static-variable-layout">layout</a>, <a href="http://localhost:63342/arva-js/docs/variable/index.html#static-variable-event">event</a>, and <a href="http://localhost:63342/arva-js/docs/variable/index.html#static-variable-flow">flow</a>) can be chained when used.</p>
<p>For example,</p>
<pre><code><code class="source-code prettyprint">    @layout.dock.top()
        .size(undefined, true)
    centeredText = Surface.with({content: &apos;This is centered!&apos;})</code>
</code></pre><p>Is the same as</p>
<pre><code><code class="source-code prettyprint">    @layout.dock.top()
    @layout.size(undefined, true)
    centeredText = Surface.with({content: &apos;This is centered!&apos;})</code>
</code></pre><h1 id="animations-and-states">Animations and states</h1><p>Animations can be described using the <a href="http://localhost:63342/arva-js/docs/variable/index.html#static-variable-flow">flow</a> operator.</p>
<p>The core concept of Flow is to animate using any of the existing <em>layout</em> operators.
When the renderable changes from one state to another using the layout operations,
their <strong>layout properties</strong> are tweened into each other, creating the effect of seamless animation.</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">    @flow.transition({duration: 200, curve: Easing.inCubic})(
        layout.size(300, 300)
    )
    animatedSurface = Surface.with({properties: {backgroundColor: &apos;red&apos;}});</code>
</code></pre>
<p>For a contextual example of using flow and animation, we made a sample component for showing and hiding a menu:</p>
<p><img src="./manual/asset/animation-demo.gif" alt="animation"></p>
<p><a href="https://github.com/Arva/demo">Source code can be found here under &apos;stateful-animations&apos;</a></p>
<h1 id="data-binding-and-views">Data binding and Views</h1><p>Every view is passed options by using the static method <code>with</code>:</p>
<pre><code><code class="source-code prettyprint">class HomeView extends View {
    @layout.fullSize()
    background = Surface.with({properties: {backgroundColor: &apos;red&apos;}})
}</code>
</code></pre><p>(See the full source code of the view <a href="https://pastebin.com/WzUJW3Vc">here</a>)</p>
<p>In order to change an option dynamically, the background color in the example is defined as an option:</p>
<pre><code><code class="source-code prettyprint">@bindings.setup({
    backgroundColor: &apos;red&apos;
})
class HomeView extends View {
....</code>
</code></pre><p>The <code>backgroundColor</code> can then be referenced inside the view:</p>
<pre><code><code class="source-code prettyprint">    background = Surface.with({
        properties:
        {
            backgroundColor: this.options.backgroundColor
        }
    })</code>
</code></pre><p>It can be changed through different triggers, one being <a href="http://localhost:63342/arva-js/docs/variable/index.html#static-variable-event">events</a>.</p>
<pre><code><code class="source-code prettyprint">    @event.on(&apos;click&apos;, function() {
        this.options.backgroundColor = &apos;green&apos;;
    })
    background = Surface.with({
            properties:
                {backgroundColor: this.options.backgroundColor
             }
        })</code>
</code></pre><h2 id="two-way-data-binding">Two-way data binding</h2><p>Data can go two ways. Referencing <code>inputOptions</code> creates a bi-directional data binding, where the value will be automatically synchronized.</p>
<pre><code><code class="source-code prettyprint">    @layout.dock.top()
        .size(undefined, true)
    question = InputSurface.with({
        placeholder: &apos;What is your name?&apos;,
        value: this.inputOptions.myName
    })

    @layout.dock.top()
        .size(undefined, true)
    answer = Surface.with({
        content: this.options.myName ?
        `Your name is ${this.options.myName}` : `You have no name`
    })</code>
</code></pre><p>For a more advanced example on databinding, we made an app that could come in handy when trying to calculate the
value of your car after a crash:</p>
<p><img src="./manual/asset/dbinding-demo.gif" alt="logo"></p>
<p><a href="https://github.com/Arva/demo">Source code can be found here under &apos;data-binding&apos;</a></p>
<h1 id="but-what-about-react-">But what about React?</h1><p>At first glance, it might not be evident what the benefit of Arva is over other frameworks. In particular, the
absence of JSX or templating language seems foreign as almost every other framework is using their own custom language.
An app written with Arva is written with plain (draft stage) ECMAScript syntax. The strict adherence to this standard future-proofs Arva to
be able to run natively in the browser, and also opens up for more super powers as the ECMAScript standard progresses further.</p>
<p>Another important difference to recall is that Arva is an MVC framework, where heavy data logic is put in the controller, rather
than being view-only, as is the case with frameworks like React. React and Arva do in this regard have different approaches,
since React is a framework intended as a component of a bigger picture, whereas Arva is the stand-alone solution for your entire app.</p>
<p>Let&apos;s consider a very simple example of an Arva view and its (approximate) counter-part in React,
to serve as a basis for further discussion.</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">@bindings.setup({
    titleText: &apos;Welcome&apos;
})
class HomeView extends View {
    @layout.dock.top(44)
    topBar = TopBar.with({titleText:this.options.titleText})

    @layout.dock.fill()
    content = Content.with()

    changeTitle(newTitle) {
        this.options.titleText = newTitle
    }
}</code>
</code></pre>
<p>And now in React. Note that this definition won&apos;t include positioning and sizing, which would need custom CSS/HTML configurations.</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">class HomeComponent extends Component {
    constructor(props, context){
        super(props, context);
        this.state = {
            titleText: props.titleText
        }
    }
    changeTitle(newTitle) {
        this.setState({titleText: newTitle})
    }

    render() {
        return (
            &lt;TopBar titleText=this.state.titleText/&gt;
            &lt;Content /&gt;
        )
    }

}
HomeComponent.defaultProps = {titleText: &apos;Welcome&apos;};</code>
</code></pre>
<h2 id="state-updates">State updates</h2><p>React is focused on building sound app logic, on simple views using the pure <code>render</code> function. Arva does not have a
render function, which means that when an update is needed (<code>setState</code> in React, or option assignment in Arva), Arva
can go a different route. When titleText is called, the function assigning <code>HomeView.topBar</code> will be called again
(<code>TopBar.with({titleText:this.options.titleText})</code>), so that the TopBar updates.</p>
<p>In the case React, the render() function will be called upon invalidation, causing a re-render of both the TopBar <em>and</em> the content.</p>
<p>We chose to optimize state updates by taking control over the <code>options</code> object of each view, linking the accesses of each
option to their relevant child views. When the child views are updated, the new options will be diffed with the old ones
in order to restrict what children should be updated inside <em>that</em> view. The getters and setters work for an arbitrary
level of nestedness inside the <code>options</code> object.</p>
<p>Based on the above description, one might object with the concern that performing deep checks for every update sounds
really inefficient. In response to that we&apos;ve learned by experience that the different <code>options</code> objects are generally
not nested or rather shallow, but rather the <em>View hierarchy</em> tends to be much more intricate. By avoiding huge
(virtual) renders of completely updated view hierarchy we instead focus on limiting this and focusing on detecting a limited
subset of <code>option</code> updates. For React developers, you might think of the options propagation to children as
 if every View was a <code>PureComponent</code>.</p>
<h2 id="layout-and-animation">Layout and Animation</h2><p>By not using JSX or other markup, we can use ES2017 decorators to focus on layout. Layout is abstracted away from the user
in order to provide flexible animations. The actual HTML output of Arva results in absolutely positioned elements in a rather
 flat structure, in order to be as flexible as possible. When using a normal framework that requires you to define the
 HTML manually, animations are usually implemented in a bit more awkward fashion.</p>
<p>All positioning and sizing done through decorators is hardware accelerated, so
the programmer can comfortably know that the animations defined won&apos;t stress the browser unnecessarily.
The decorator structure of Arva provides a natural solution for layout definition. In order to clarify why this is important,
 we will revisit the example we covered in a previous section, with the animating hamburger icon:</p>
<p><img src="./manual/asset/button.gif" alt="button"></p>
<p>The animation declaration is optimized in being as straight forward as possible, so that transition states are defined
in an additive nature from the previous position, while tasks like centering content in relation to parent and proportional
 size are still easy to achieve.</p>
<p>Here&apos;s the code, with plenty of comments, for clarity:</p>
<pre><code class="lang-javascript"><code class="source-code prettyprint">    /* We start with the top part of the hamburger,
    * which starts in a horizontal state
    */
    /* We center it as default, but it&apos;s translated relative to that further down */
    @layout.stick.center()
    /* Size is 60% of parent size and 3 pixels high */
        .size(0.6, 3)
    /* options.isOpen is a boolean signaling whether the menu is open or not */
    @dynamic(({isOpen}) =&gt;
        /* This is the animation for going to the X.
        * This makes the top bar tilted. */
        isOpen ? flow
                .transition()(
                    /* The first part of tilting the stick involves
                    * centering all three lines together.
                    * That means that we center the top part, by translating it to the middle */
                    layout
                        .translate(0, 0, 0))
                .transition()(
                    /* We then rotate it 45 degrees, which is the same as Math.PI / 4 */
                    layout
                        .rotate(0, 0, Math.PI / 4))
            :
            /* We translate 8 pixels upwards in the default state */
            flow.transition()(
                /* (if coming back), compress again before going to the original state */
                layout.rotate(0, 0, 0)
            ).transition() (
                layout.translate(0, -8, 0)
            )
    )
    /* We defined a simple component with a white background
    * which is used for every portion of the icon
    */
    topStick = WhiteShape.with();

    /* The middle part is easy. We just hide it when the icon turns into
    *  the X (since that&apos;s just two lines instaed of three) */
    @dynamic(({isOpen}) =&gt;
        isOpen ? flow.transition()(
            layout.opacity(0)
            ) :
            flow.transition()(
                layout
                    .stick.center()
                    .translate(0, 0, 0)
                    .size(0.6, 3)
                    .opacity(1)
            )
    )
    centerStick = WhiteShape.with();

    /* The bottom part is very similar to the top one,
    * but with a rotation going in the opposite direction,
    * and a translate 8 pixels down instead of 8 pixels up
    */
    @layout.stick.center()
        .size(0.6, 3)
    @dynamic(({isOpen}) =&gt;
        isOpen ? flow
                .transition({})(
                    layout
                        .translate(0, 0, 0))
                .transition()(
                    layout
                        .rotate(0, 0, - Math.PI / 4))
            :
            flow.transition()(
                layout.rotate(0, 0, 0)
            ).transition() (
                layout.translate(0, 8, 0)
            )
    )
    bottomStick = WhiteShape.with();</code>
</code></pre>
<h1 id="the-bigger-picture">The bigger picture</h1><p>We will continue to improve Arva JS in every aspect, including performance, UX possibilities and code brevity. It&apos;s a framework
that is going to be frequently revised and evaluated for its goals.</p>
<p>Arva Foundation is just the start of a series of tools to accelerate digital product development.
If you want a sneak peak into our future, have a look at [arva.io].</p>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
