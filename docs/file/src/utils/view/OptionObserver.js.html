<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/utils/view/OptionObserver.js | Arva</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-styles.css"><meta name="description" content="this is awesome library"><meta property="og:type" content="website"><meta property="og:url" content="http://arva.io"><meta property="og:site_name" content="Arva"><meta property="og:title" content="Arva"><meta property="og:image" content="http://arva.io/img/logo-arva.png"><meta property="og:description" content="this is awesome library"><meta property="og:author" content="https://twitter.com/arvamazing"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Arva"><meta property="twitter:description" content="this is awesome library"><meta property="twitter:image" content="http://arva.io/img/logo-arva.png"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.png" style="width:34px;"></a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Arva/arva-js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#components">components</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/DataBoundScrollView.js~DataBoundScrollView.html">DataBoundScrollView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/Dialog.js~Dialog.html">Dialog</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/components/ReflowingScrollView.js~ReflowingScrollView.html">ReflowingScrollView</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core">core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/App.js~App.html">App</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Controller.js~Controller.html">Controller</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Model.js~Model.html">Model</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/Router.js~Router.html">Router</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/ScrollController.js~ScrollController.html">ScrollController</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/View.js~View.html">View</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#data">data</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/PrioritisedArray.js~PrioritisedArray.html">PrioritisedArray</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#data-local">data/local</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/local/LocalModel.js~LocalModel.html">LocalModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/data/local/LocalPrioritisedArray.js~LocalPrioritisedArray.html">LocalPrioritisedArray</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#layout">layout</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/layout/Decorators.js~Event.html">Event</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/layout/Decorators.js~Flow.html">Flow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/layout/Decorators.js~Layout.html">Layout</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dynamic">dynamic</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-decoratorTypes">decoratorTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-bindings">bindings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-event">event</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-flow">flow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-layout">layout</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-flowStates">flowStates</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StickTypes">StickTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-StickTypes">StickTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-dockBottom">dockBottom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-dockLeft">dockLeft</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-dockRight">dockRight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-dockTop">dockTop</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-fill">fill</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#routers">routers</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/routers/ArvaRouter.js~ArvaRouter.html">ArvaRouter</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#surfaces">surfaces</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/surfaces/AudioSurface.js~AudioSurface.html">AudioSurface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/surfaces/Dropdown.js~Dropdown.html">Dropdown</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/surfaces/InputSurface.js~InputSurface.html">InputSurface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/surfaces/PushDownSurface.js~PushDownSurface.html">PushDownSurface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/surfaces/WebGLSurface.js~WebGLSurface.html">WebGLSurface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BgImageSurface">BgImageSurface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Surface">Surface</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils">utils</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/BlobHelper.js~BlobHelper.html">BlobHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/DialogManager.js~DialogManager.html">DialogManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/Injection.js~Injection.html">Injection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/KeyboardHelper.js~KeyboardHelper.html">KeyboardHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/ObjectHelper.js~ObjectHelper.html">ObjectHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/Throttler.js~Throttler.html">Throttler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-callbackToPromise">callbackToPromise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-successAndErrorToPromise">successAndErrorToPromise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-waitMilliseconds">waitMilliseconds</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-combineOptions">combineOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-limit">limit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Easing">Easing</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils-dialog">utils/dialog</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/dialog/DialogWrapper.js~DialogWrapper.html">DialogWrapper</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils-hotfixes">utils/hotfixes</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-invalidateLayoutForElement">invalidateLayoutForElement</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils-view">utils/view</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/ArrayObserver.js~ArrayObserver.html">ArrayObserver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/ArrayObserver.js~MappedArray.html">MappedArray</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/InputOption.js~InputOption.html">InputOption</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/LayoutHelpers.js~BaseLayoutHelper.html">BaseLayoutHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/LayoutHelpers.js~DockedLayoutHelper.html">DockedLayoutHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/LayoutHelpers.js~FullSizeLayoutHelper.html">FullSizeLayoutHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/LayoutHelpers.js~TraditionalLayoutHelper.html">TraditionalLayoutHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/LazyLoadedOptionClone.js~LazyLoadedOptionClone.html">LazyLoadedOptionClone</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/OptionObserver.js~OptionObserver.html">OptionObserver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/RenderableHelper.js~RenderableHelper.html">RenderableHelper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/SizeResolver.js~SizeResolver.html">SizeResolver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/view/Utils.js~Utils.html">Utils</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-changeValue">changeValue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-onOptionChange">onOptionChange</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/utils/view/OptionObserver.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Created by lundfall on 23/02/2017.
 */
import EventEmitter from &apos;eventemitter3&apos;;

import cloneDeepWith from &apos;lodash/cloneDeepWith&apos;;
import difference from &apos;lodash/difference&apos;;
import each from &apos;lodash/each&apos;;

import Timer from &apos;famous/utilities/Timer.js&apos;;
import {RenderablePrototype} from &apos;famous/utilities/RenderablePrototype.js&apos;;

import {Utils} from &apos;./Utils.js&apos;;
import {ArrayObserver} from &apos;./ArrayObserver.js&apos;;
import {
    InputOption, unwrapValue,
    changeValue, storedInputOption
} from &apos;./InputOption&apos;;
import {ObjectHelper} from &apos;../ObjectHelper&apos;;
import {PrioritisedObject} from &apos;../../data/PrioritisedObject&apos;;
import {Model} from &apos;../../core/Model&apos;;
import {PrioritisedArray} from &apos;../../data/PrioritisedArray&apos;;
import {LazyLoadedOptionClone} from &apos;./LazyLoadedOptionClone&apos;;


/* Symbols are used for many properties in order to allow any arbitrary names of options. The names are
 * repeated for the symbols and variable names in order to make debuggability easier */
let newChanges = Symbol(&apos;newChanges&apos;),
    originalValue = Symbol(&apos;originalValue&apos;),
    oldValue = Symbol(&apos;oldValue&apos;),
    instanceIdentifier = Symbol(&apos;instanceIdentifier&apos;),
    isArrayListener = Symbol(&apos;isArrayListener&apos;),
    optionRecorder = Symbol(&apos;optionRecorder&apos;),
    arrayRecorder = Symbol(&apos;arrayRecorder&apos;);

/* Some symbols are exported since they are used elsewhere. Note that the triggers symbol is defined directly on
*  the OptionObserver to make it easier to access from outside Arva (not just in internal classes) */
export let onOptionChange = Symbol(&apos;onOptionChange&apos;),
    storedArrayObserver = Symbol(&apos;storedArrayObserver&apos;),
    notFound = Symbol(&apos;notFound&apos;),
    listeners = Symbol(&apos;listeners&apos;),
    optionMetaData = Symbol(&apos;optionMetaData&apos;);

//TODO fix falsey value checks, should behave differently for undefined and false

//TODO Not sure if the (nested) array listener tree is setup with maximum efficiency. Furthermore, partial array updates isn&apos;t supported

//TODO Think how to solve the case when this.options is passed as a whole to a renderable, maybe there should be a way to state explicit dependence if needed. Maybe implementing a getter trigger of the option on the view can be a viable idea

export class OptionObserver extends EventEmitter {
    /* The structure of what thing in the objects is mapped to the corresponding renderable update */
    _listenerTree = {};
    /* An array of nested objects representing a reverse lookup to the listener tree */
    _reverseListenerTree = {};
    _newReverseListenerTree = {};
    _listenerTreeMetaData = {};
    /* We have to keep track of the models, because they use their own getter/setter hooks and we can&apos;t use the builtin ones */
    _modelListeners = {};
    _activeRecordings = {};
    /* This contains the option difference to indicate a value change */
    _newOptionUpdates = {};
    _updatesForNextTick = {};
    _forbiddenUpdatesForNextTick = {};
    _listeningToSetters = true;
    _arrayObservers = [];

    /* The max supported depth in deep-checking iterations */
    static maxSupportedDepth = 10;
    /* Used for trigger function of options, which is a special type of update */
    static triggers = Symbol(&apos;triggers&apos;);

    /**
     *
     * @param defaultOptions
     * @param options
     * @param {Array&lt;Function&gt;} bindingsTriggerFunctions
     * @param debugName Used for displaying error messages and being able to trace them back more easily
     */
    constructor(defaultOptions, options, bindingsTriggerFunctions, debugName) {
        super();
        this._errorName = debugName;
        this._bindingsTriggerMethods = bindingsTriggerFunctions || [];
        OptionObserver._registerNewInstance(this);
        this.defaultOptions = defaultOptions;
        this.options = options;
        if (!window.optionObservers) {
            window.optionObservers = [];
        }
        window.optionObservers.push(this);
    }

    /**
     * Records the updates that happen in options and models (intended to be called before the construction of that renderable)
     * @param renderableName
     * @param callback
     */
    recordForRenderable(renderableName, callback) {
        this._recordForEntry([renderableName], false);
        callback();
        this._stopRecordingForEntry(renderableName);
    }

    /**
     * Returns the options that are being observed
     * @returns {*}
     */
    getOptions() {
        return this.options
    }

    /**
     * Should be called when the renderable isn&apos;t relevant anymore
     * @param {String} renderableName
     */
    deleteRecordingForRenderable(renderableName) {
        //todo implement this (is an efficient way)
    }

    getInputOptions() {
        if (this._inputOptions) {
            return this._inputOptions;
        }
        return this._inputOptions = LazyLoadedOptionClone.get(InputOption, this.options, this._listenerTree, [], this);
    }

    /**
     * Executes the trigger function. The trigger function is treated similarly to that of a renderable,
     * but it&apos;s identified with the symbol OptionObserver.triggers accompanied by an index, instead of a string
     *
     * Different examples of trigger situations:
     * Scenario 1: Construction
     * A. The trigger function is called
     * B. Getters are detected for the pre-process function
     * C. this.options isn&apos;t set, so nothing more happens
     *
     * TODO This description is outdated
     *
     * Scenario 2. Setter trigger of a trigger function
     * A. After flushing, it is concluded to belong to the trigger function (and other renderables)
     * B. The trigger function is triggered immediately and firstly when flushing change events
     * C. The trigger function re-executes the function and getters are triggered again
     * D. this.options is defined, and it setters will be notified.
     * E. An inner flush is forced within the flush, and it there might be new renderables needing update now
     * F. The flush completes and resets the _updatesForNextTick
     * G. The outer flush continues, and has nothing more to do
     * H. Since we made changes within a flush, the static OptionObserver loop _flushAllUpdates, will call the flush function once again, but doing nothing
     *
     * Scenario 3. Recombine options
     * A. After flushing, it is concluded that the option changes belong to one of the trigger functions (and other renderables)
     * B. Continues same as scenario 2.
     *
     * @private
     */
    triggerMethodForIndex(incomingOptions, index) {
        if (!this._bindingsTriggerMethods[index]) {
            return this._throwError(`Internal error in OptionObserver: trigger function with index ${index} doesn&apos;t exist`)
        }

        this._recordForTriggerMethod(() =&gt;
            this._bindingsTriggerMethods[index](this), index);
        /* Prevent the trigger method from being triggered within the next flush. This is important
         * to do in case the trigger function sets variables that it also gets, (ie if(!options.color) options.color = &apos;red&apos;)
         */
        this.preventEntryFromBeingUpdated([OptionObserver.triggers, index])
    }

    preventEntryFromBeingUpdated(entryNames) {
        this._accommodateInsideObject(this._forbiddenUpdatesForNextTick, entryNames, true)
    }


    allowEntryToBeUpdated(entryNames){
        let forbiddenUpdates = this._forbiddenUpdatesForNextTick;
        for(let [index, entryName] of entryNames.entries()){
            let forbiddenUpdateKeys = Object.keys(forbiddenUpdates);
            if(forbiddenUpdateKeys.length === 1 || index === entryNames.length - 1){
                delete forbiddenUpdates[forbiddenUpdateKeys[0]];
                break;
            }
            forbiddenUpdates = forbiddenUpdates[entryName];
            if(!forbiddenUpdates){
                return;
            }
        }
    }


    setup() {
        this._createListenerTree();
        //todo this order changed, we used to do the option merging after trigger function. What is needed? Pass option to adjust behaviour?
        this._updatesForNextTick[OptionObserver.triggers] = new Array(this._bindingsTriggerMethods.length).fill(true);
        this._markAllOptionsAsUpdated();
    }

    /**
     * Used by InputOption to determine which recording is currently active
     * @returns {{}}
     */
    getActiveRecordings() {
        return this._activeRecordings;
    }

    getListenerTree() {
        return this._listenerTree;
    }

    /**
     * Similar to _.get, except that it returns notFound (a symbol) when not found. It also supports tarversing listeners
     * @param object
     * @param path
     * @param traverseListeners
     * @returns {*}
     * @private
     */
    accessObjectPath(object, path, traverseListeners = false) {
        for (let pathString of path) {
            if (!object || !object.hasOwnProperty(pathString)) {
                if (traverseListeners) {
                    if (Array.isArray(object)) {
                        pathString = 0
                    }
                } else {
                    return notFound
                }
            }
            object = object[pathString];
            /* If it&apos;s a specially registered array listener, the property to read is called value and is being
             *  used on the listener tree */
            if (object &amp;&amp; object[isArrayListener] &amp;&amp; traverseListeners) {
                /* Return immediately, ignore remaining properties in path. TODO: Verify that this is what we want*/
                return object.value;
            }
        }
        return object
    }


    /**
     * Gets the entry names that are there for a certain listener tree
     * @param localListenerTree
     * @returns {Array.&lt;*&gt;}
     */
    _getUpdatesEntryNamesForLocalListenerTree(localListenerTree) {
        let forbiddenUpdatesForNextTick = this._forbiddenUpdatesForNextTick;
        let doubleNestedPaths = Object.keys(localListenerTree)
            .concat(localListenerTree[OptionObserver.triggers] ? OptionObserver.triggers : [])
            .map((key) =&gt; localListenerTree[key] === true ? [[key]] :
                this._getDeeplyNestedListenerPaths(localListenerTree[key]).map((path) =&gt; [key].concat(path)));

        /* Flatten double nested paths */
        let paths = [].concat(...doubleNestedPaths);
        /* Make sure that we are not updating something that is forbidden during this tick */
        let forbiddenUpdatePathsForNextTick = Object.keys(forbiddenUpdatesForNextTick).concat(
            forbiddenUpdatesForNextTick[OptionObserver.triggers] ? OptionObserver.triggers : []);
        if(forbiddenUpdatePathsForNextTick.length){
            paths = paths.filter((path) =&gt; {
                return this.accessObjectPath(this._forbiddenUpdatesForNextTick, path) === notFound
            });
        }
        return paths;

    }

    _recordForTriggerMethod(callback, triggerIndex) {
        this._recordForEntry([OptionObserver.triggers, triggerIndex], true);
        callback();
        this._stopRecordingForEntry(OptionObserver.triggers)
    }

    /**
     * Records for a specific entry
     * @param {Array} entryNames
     * @param {Boolean} allowSetters
     * @private
     */
    _recordForEntry(entryNames, allowSetters) {
        this._accommodateInsideObject(this._activeRecordings, entryNames, {});
        this._beginListenerTreeUpdates(entryNames);
        this._listenForModelUpdates(entryNames);
        //todo need to set optionRecorder as a symbol
        let opOptionTrigger = this.accessObjectPath(this._activeRecordings, entryNames)[optionRecorder] = ({type, propertyName, nestedPropertyPath}) =&gt; {
            if (type === &apos;setter&apos;) {
                if (allowSetters) {
                    /* Be sure to avoid infinite loops if there are setters that trigger getters that are matched to this
                     *  recording */
                    this.preventEntryFromBeingUpdated(entryNames)
                } else {
                    this._throwError(&apos;Setting an option during instanciation of renderable&apos;)
                }
            } else {
                let localListenerTree = this._accessListener(nestedPropertyPath.concat(propertyName));
                this._addToListenerTree(entryNames, localListenerTree)
            }
        };
        this.on(&apos;optionTrigger&apos;, opOptionTrigger)
    }

    /**
     * Accesses a listener in a certain path
     * @param nestedPropertyPath
     * @returns {*}
     * @private
     */
    _accessListener(nestedPropertyPath) {
        return this.accessObjectPath(this._listenerTree, nestedPropertyPath, true);
    }

    /**
     *
     * @param {Array} entryNames
     * @param {Object} localListenerTree
     * @private
     */
    _addToListenerTree(entryNames, localListenerTree) {

        let listenerStructure = localListenerTree[listeners];

        /* Renderable already added to listener tree, so no need to do that again */
        let {listenersCanChange, listenersChanged, matchingListenerIndex} = this.accessObjectPath(this._listenerTreeMetaData, entryNames);

        this.accessObjectPath(this._newReverseListenerTree, entryNames).push(listenerStructure);

        if (listenersCanChange &amp;&amp; !listenersChanged) {
            /* We optimize the most common use case, which is that no listeners change.
             *  In that case, the order of listeners will be the same, otherwise we need to accommodate*/

            let reverseListenerTree = this.accessObjectPath(this._reverseListenerTree, entryNames);
            let listenerTreeMetaData = this.accessObjectPath(this._listenerTreeMetaData, entryNames);

            if (reverseListenerTree[matchingListenerIndex] !== listenerStructure) {
                listenerTreeMetaData.listenersChanged = true
            }

            listenerTreeMetaData.matchingListenerIndex++
        }

        this._accommodateInsideObject(listenerStructure, entryNames, true)

    }

    /**
     * Performs all available bindings triggering functions
     * @param incomingOptions
     * @private
     */
    _doAllTriggerMethods(incomingOptions) {
        for (let [index] of this._bindingsTriggerMethods.entries()) {
            this.triggerMethodForIndex(incomingOptions, index)
        }
    }

    _endListenerTreeUpdates(renderableName) {
        if (this._listenerTreeMetaData[renderableName].listenersChanged) {
            let oldListeners = this._reverseListenerTree[renderableName];
            /* Remove the old listeners and add the new ones again. In this way, we get O(n + m) complexity
             *  instead of O(m*n) */
            for (let listenerTree of oldListeners) {
                delete listenerTree[renderableName]
            }
            let newListeners = this._newReverseListenerTree[renderableName];

            for (let listenerTree of newListeners) {
                listenerTree[renderableName] = true
            }

        }
        this._reverseListenerTree[renderableName] = this._newReverseListenerTree[renderableName];
        delete this._newReverseListenerTree[renderableName]
    }

    _beginListenerTreeUpdates(entryNames) {
        /* The listener meta data sets a counter in order to match the new listeners in comparison to the old listeners*/
        let numberOfExistingListenerPaths = this.accessObjectPath(this._reverseListenerTree, entryNames.concat(&apos;length&apos;));
        if (numberOfExistingListenerPaths === notFound) {
            numberOfExistingListenerPaths = 0
        }
        this._accommodateInsideObject(this._listenerTreeMetaData, entryNames, {
            matchingListenerIndex: 0,
            listenersCanChange: !!numberOfExistingListenerPaths,
            listenersChanged: false
        });
        this._accommodateInsideObject(this._newReverseListenerTree, entryNames, [])

    }

    /**
     * Called when a renderable shouldn&apos;t be recorded anymore
     * @param entryName
     */
    _stopRecordingForEntry(entryName) {
        this._endListenerTreeUpdates(entryName);
        PrioritisedObject.removePropertyGetterSpy();
        this.removeListener(&apos;optionTrigger&apos;, this._activeRecordings[entryName][optionRecorder]);
        // Todo when we start listening for mapcalled, use this code (if that is what we&apos;ll do)
        //this.removeListener(&apos;mapCalled&apos;, this._activeRecordings[entryName][arrayRecorder]);
        delete this._activeRecordings[entryName]
    }

    /**
     * Updates the options from an external reason
     * @param newOptions
     */
    recombineOptions(newOptions = {}) {
        let newOptionsAreAlsoOptions = !!newOptions[optionMetaData];
        if (newOptionsAreAlsoOptions) {
            if (newOptions === this.options) {
                return
            }
            this.options = newOptions;
            this._markAllOptionsAsUpdated();
            return
        }
        this._deepTraverse(this.options, (nestedPropertyPath, optionObject, existingOptionValue, key, [newOptionObject, defaultOption]) =&gt; {
            let newOptionValue = newOptionObject[key];
            if (newOptionValue === undefined &amp;&amp; optionObject[key] !== null) {     //todo confirm whether this check is appropriate (I don&apos;t think it is)
                let defaultOptionValue = defaultOption[key];
                if (defaultOptionValue !== newOptionValue &amp;&amp; (defaultOptionValue !== existingOptionValue &amp;&amp;
                        /* If new value is undefined, and the previous one was already the default, then don&apos;t update (will go false)*/
                        !Utils.isPlainObject(existingOptionValue) &amp;&amp; existingOptionValue[optionMetaData] &amp;&amp; existingOptionValue[optionMetaData].isDefault)
                ) {
                    this._markPropertyAsUpdated(nestedPropertyPath, key, newOptionObject[key], existingOptionValue)
                }
                /* Cancel traversion in this direction */
                return true
            } else if (!(newOptionValue &amp;&amp; Utils.isPlainObject(newOptionValue)) &amp;&amp; existingOptionValue !== newOptionValue) {
                /* Triggers the appriopriate events */
                this._markPropertyAsUpdated(nestedPropertyPath, key, newOptionObject[key], existingOptionValue)
            }
        }, [newOptions, this.defaultOptions]);

        /* Flush the updates in order to trigger the updates immediately */
        this.flushUpdates()
    }


    _markAllOptionsAsUpdated() {
        let rootProperties = Object.keys(this.defaultOptions);
        this._updateOptionsStructure(rootProperties, this.options, [], rootProperties.map((rootProperty) =&gt; undefined));
        this.flushUpdates()
    }

    _setupOptionLink(object, key, newValue, nestedPropertyPath, listenerTree) {

        if (this._isMyOption(newValue)) {
            /* Shallow clone at this level, which will become a deep clone when we&apos;re finished traversing */
            newValue = this._shallowCloneOption(newValue)
        }

        /* Only add the getter/setter hook if there isn&apos;t one yet */
        this._addGetterSetterHook(object, key, newValue, nestedPropertyPath, listenerTree);
        //TODO there might be more optimal ways of doing this, the option will be marked 4-5 times on setup
        this._markAsOption(object);
        this._markAsOption(newValue);
        return newValue
    }

    _isMyOption(value) {
        return Utils.isPlainObject(value) &amp;&amp; value[optionMetaData] &amp;&amp; value[optionMetaData].owners.includes(this)
    }

    _shallowCloneOption(optionToShallowClone) {
        if (!Utils.isPlainObject(optionToShallowClone)) {
            return optionToShallowClone
        }
        let result = {};
        Object.defineProperties(result, Object.getOwnPropertyDescriptors(optionToShallowClone));
        return result
    }

    /**
     * Adds a getter/setter hook to a certain object for a key with a value, where object[key]===value.
     * @param object
     * @param key
     * @param value
     * @param {Array} nestedPropertyPath
     * @param {Object} listenerTree
     * @private
     */
    _addGetterSetterHook(object, key, value, nestedPropertyPath, listenerTree) {
        ObjectHelper.addGetSetPropertyWithShadow(object, key, value, true, true,
            (info) =&gt;
                this._onEventTriggered({...info, type: &apos;setter&apos;, parentObject: object, nestedPropertyPath, listenerTree})
            , (info) =&gt;
                this._onEventTriggered({...info, type: &apos;getter&apos;, parentObject: object, nestedPropertyPath, listenerTree}))
    }

    /**
     * Called when a model is changed
     * @param model
     * @param {Array} changedProperties
     * @param {String} modelKeyInParent The key of the parent object
     * @param {Array} nestedPropertyPath
     * @private
     */
    _onModelChanged(model, changedProperties, modelKeyInParent, nestedPropertyPath) {
        let nestedPropretyPathToModel = nestedPropertyPath.concat(modelKeyInParent);
        /* We need to check for undefined options here, since we can catch unreferenced properties, which we should ignore */
        //TODO Optimize so that the listener doesn&apos;t have to be accessed twice when the check doesn&apos;t go through
        let localListenerTree = this._accessListener(nestedPropretyPathToModel);
        if (!localListenerTree) {
            return;
        }
        changedProperties = changedProperties.filter((changedProperty) =&gt; localListenerTree[changedProperty]);
        if (!changedProperties.length) {
            return;
        }
        this._updateOptionsStructure(changedProperties, model, nestedPropretyPathToModel);
    }

    /**
     * Happens when an event is triggered (getter/setter)
     * @param {Object} info ({ nestedPropertyPath, propertyName, parentObject })
     * @private
     */
    _onEventTriggered(info) {
        if (this._ignoreListeners) {
            return;
        }
        this.emit(&apos;optionTrigger&apos;, info);

        if (info.type === &apos;setter&apos; &amp;&amp; this._listeningToSetters) {
            /* In order to avoid accidentally triggering getters when reading and manipulating data, set boolean flag */
            this._ignoreListeners = true;
            let {nestedPropertyPath, propertyName, parentObject, oldValue, newValue} = info;
            /* If reassignment to exactly the same thing, then don&apos;t do any update */
            if (oldValue !== newValue) {
                this._updateOptionsStructure([propertyName], parentObject, nestedPropertyPath, [oldValue]);
            }
            this._ignoreListeners = false;
        } else if (info.type === &apos;getter&apos; &amp;&amp; info.listenerTree[storedInputOption]){
            for(let inputOption of info.listenerTree[storedInputOption]){
                inputOption.updateValueIfNecessary();
            }
        }
    }

    /**
     * Deep updates the options based on parameter
     * @param changedProperties
     * @param parentObject
     * @param nestedPropertyPath
     * @param oldValues
     * @private
     */
    _updateOptionsStructure(changedProperties, parentObject, nestedPropertyPath, oldValues = []) {
        for (let [index, property] of changedProperties.entries()) {
            this._markPropertyAsUpdated(nestedPropertyPath, property, parentObject[property], oldValues[index])
        }
    }

    flushUpdates() {
        this._flushArrayObserverChanges();
        /* Do a traverse only for the leafs of the new updates, to avoid doing extra work */
        this._deepTraverseWithShallowArrays(this._newOptionUpdates, (nestedPropertyPath, updateObjectParent, updateObject, propertyName, [defaultOptionParent, listenerTree, optionObject]) =&gt; {
                    this._handleNewOptionUpdateLeaf(nestedPropertyPath, updateObject, propertyName, defaultOptionParent, listenerTree, optionObject);
            }, [this.defaultOptions, this._listenerTree, this.options],
            [true, false, false],
            true
        );
        this._newOptionUpdates = {};
        this._handleResultingUpdates();
        this.emit(&apos;postFlush&apos;);
    }

    /**
     * Marks a certain property as updated
     * @param nestedPropertyPath
     * @param propertyName
     * @param value
     * @param oldValue
     * @private
     */
    _markPropertyAsUpdated(nestedPropertyPath, propertyName, value, oldValue) {

        OptionObserver._markInstanceAsDirty(this);
        /* Mark the object as changes in the most common path */
        let updateObject = this._accommodateObjectPathUnless(this._newOptionUpdates, nestedPropertyPath, (object) =&gt;
            object[newChanges]
        );
        /* We rest upon the assumption that no function can access a nested path (options.nested.myString)
         * without also accessing intermediary properties (options.nested getter is triggered). If this isn&apos;t
         * true for some reason, updates will be missed */
        if (updateObject !== notFound) {
            let fullNestedPropertyPath = nestedPropertyPath.concat([propertyName]);
            let localListenerTree = this._accessListener(fullNestedPropertyPath);
            if (!localListenerTree || !(localListenerTree[listeners] || localListenerTree[0])) {
                this._throwError(`Assignment to undefined option ${fullNestedPropertyPath.join(&apos;-&gt;&apos;)}`);
            }
            let localListeners = localListenerTree[listeners] || localListenerTree[0][listeners];
            for (let entryNames of this._getUpdatesEntryNamesForLocalListenerTree(localListeners)) {
                this._accommodateInsideObject(this._updatesForNextTick, entryNames, true)
            }
            updateObject[propertyName] = {
                [newChanges]: value,
                [originalValue]: oldValue
            };
            this.emit(&apos;propertyUpdated&apos;, {nestedPropertyPath, propertyName, value, oldValue});
        }
    }

    /**
     * Traverses an object with shallow arrays. Thin wrapper around deepTraverse
     *
     * @param object
     * @param callback with arguments (nestedPropertyPath, object, value, key, {Array} extraObjectsToTraverse)
     * @param {Array} extraObjectsToTraverse A couple of extra objects that are assumed to have the same structure
     * @param {Array} isShallowObjects An array with the same length as extraObjectsToTraverse, with booleans indicating whether
     * the objects are shallow (for example, the default options specified for arrays)
     * @param {Boolean} onlyForLeaves
     * @param {Array} nestedPropertyPath Used to keep track of the current nestedPropertyPath
     * @param {Number} depthCount Internally used depth count to prevent infinite (or too nested) recursion
     * @private
     */
    _deepTraverseWithShallowArrays(object,
                                   callback,
                                   extraObjectsToTraverse = [],
                                   isShallowObjects = [],
                                   onlyForLeaves = false,
                                   nestedPropertyPath = [],
                                   depthCount = 0) {
        return this._deepTraverse(
            object,
            callback,
            extraObjectsToTraverse,
            (suggestedTraversals, key, parents) =&gt;
                Array.isArray(parents[0]) ? isShallowObjects.map((isShallowObject, index) =&gt; isShallowObject ? parents[index][0] : suggestedTraversals[index])
                    : suggestedTraversals,
            onlyForLeaves,
            nestedPropertyPath,
            depthCount
        )
    }



    _getDeeplyNestedListenerPaths(localListenerTree, accumulator = []) {
        if (localListenerTree === true) {
            return accumulator;
        }
        let nestedPaths = [];
        for (let key in localListenerTree) {
            let nestedPath = this._getDeeplyNestedListenerPaths(localListenerTree[key], accumulator.concat(key));
            /* If the resulting paths are doubled nested, then they need to be flattened one step */
            if (Array.isArray(nestedPath[0])) {
                nestedPaths.push(...nestedPath);
            } else {
                nestedPaths.push(nestedPath);
            }
        }
        return nestedPaths;
    }

    /**
     * Mark an object as being part of an option
     * @param objectInOptionStructure
     * @private
     */
    _markAsOption(objectInOptionStructure) {
        if (!Utils.isPlainObject(objectInOptionStructure)) {
            return
        }
        //TODO This might be able to be optimized
        let originalOwners = (objectInOptionStructure[optionMetaData] &amp;&amp; objectInOptionStructure[optionMetaData].owners) || [];
        if (!originalOwners.includes(this)) {
            objectInOptionStructure[optionMetaData] = {
                owners: originalOwners.concat(this)
            }
        }

    }

    _throwError(message) {
        throw new Error(`${this._errorName}: ${message}`)
    }

    /**
     * Sets up a model that will be synchronized to update the options object whenever something is updated, after startListener() is called
     *
     * @param nestedPropertyPath
     * @param model
     * @param localListenerTree
     * @param property
     * @private
     */
    _setupModel(nestedPropertyPath, model, localListenerTree, property) {

        //TODO This won&apos;t work if the id can be set to something else, so verify that this shouldn&apos;t be possible
        /* We assume that the constructor name is unique */
        let onModelChanged = (model, changedProperties) =&gt;
            this._onModelChanged(model, changedProperties, property, nestedPropertyPath);
        let isListening = false;
        for(let property of Object.keys(model)){
            if(!localListenerTree[property]){
                localListenerTree[property] = {[listeners]: {}};
            }
        }
        return this._accommodateObjectPath(this._modelListeners, [model.constructor.name])[model.id] = {
            startListening: () =&gt; {
                if (!isListening) {
                    model.on(&apos;changed&apos;, onModelChanged);
                    isListening = true
                }
            },
            stopListening: () =&gt; {
                if (isListening) {
                    model.removeListener(&apos;changed&apos;, onModelChanged);
                    isListening = false
                }
            },
            localListenerTree,
            nestedPropertyPath: nestedPropertyPath.concat(property),
            isListening: () =&gt; isListening
        }
    }

    /**
     * Deep traverses an object
     * @param object
     * @param callback with arguments (nestedPropertyPath, object, value, key, {Array} extraObjectsToTraverse)
     * @param {Array} extraObjectsToTraverse A couple of extra objects that are assumed to have the same structure
     * @param {Function} extraObjectProcessor Function to do extra work for the extra objects to process
     * @param {Boolean} onlyForLeaves
     * @param {Array} nestedPropertyPath Used to keep track of the current nestedPropertyPath
     * @param {Number} depthCount Internally used depth count to prevent infinite (or too nested) recursion
     * @private
     */

    /*TODO Refactor this function to use name parameters instead of order-based parameters */
    _deepTraverse(object,
                  callback,
                  extraObjectsToTraverse = [],
                  extraObjectProcessor = (item) =&gt; item,
                  onlyForLeaves = false,
                  nestedPropertyPath = [],
                  depthCount = 0) {
        if (!Utils.isPlainObject(object) &amp;&amp; !Array.isArray(object)) {
            return
        }
        if (depthCount &gt; OptionObserver.maxSupportedDepth) {
            this._throwError(`Encountered circular structure or an exceeded maximum depth of ${OptionObserver.maxSupportedDepth} exceeded`)
        }
        each(object, (value, key) =&gt; {

            let valueIsPlainObject = value &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value.constructor.name === &apos;Object&apos;;
            let valueIsLeaf = valueIsPlainObject &amp;&amp; Object.keys(value).length === 0;
            if (!onlyForLeaves || valueIsLeaf) {
                /* If the callback returns true, then cancel traversion */
                if (callback(nestedPropertyPath, object, value, key, extraObjectsToTraverse)) {
                    return //canceled traverse
                }
            }
            if (valueIsPlainObject) {
                this._deepTraverse(
                    value,
                    callback,
                    extraObjectProcessor(extraObjectsToTraverse.map(
                        (extraObjectToTraverse) =&gt; extraObjectToTraverse[key] || {}
                    ), key, extraObjectsToTraverse),
                    extraObjectProcessor,
                    onlyForLeaves,
                    nestedPropertyPath.concat(key),
                    depthCount + 1
                )
            }
        })
    }

    /**
     * When properties are removed from options, they are reset to the value specified
     * @private
     * @param newValue
     * @param oldValue
     * @param defaultOptionValue
     */
    _resetRemovedPropertiesIfNeeded(newValue, oldValue, defaultOptionValue) {
        if (!oldValue || !Utils.isPlainObject(oldValue) || !defaultOptionValue) {
            return
        }
        let properties = Object.keys(newValue);
        let oldProperties = Object.keys(oldValue);

        let removedProperties = difference(oldProperties, properties);

        for (let property of removedProperties) {
            newValue[property] = defaultOptionValue[property]
        }
    }

    /**
     * Compares something to see if it&apos;s predictibly equal
     * @param firstThing
     * @param secondThing
     * @returns {boolean}
     * @private
     */
    _isPredictablyEqual(firstThing, secondThing) {
        /* Object comparison is not reliable */
        if (Utils.isPlainObject(firstThing)) {
            return false
        }
        return firstThing === secondThing
    }

    /**
     * Stops when any path is found with certain criteria
     * @param object
     * @param path
     * @param criteriaCallback
     * @returns {*}
     * @private
     */
    _accommodateObjectPathUnless(object, path, criteriaCallback) {
        for (let property of path) {
            if (object[property] &amp;&amp; criteriaCallback(object[property])) {
                return notFound
            }
            object[property] = {};
            object = object[property]
        }
        return object
    }

    /**
     * Accommodates a path in an object
     * @param object
     * @param {Array&lt;String&gt;} path
     * @returns {*}
     * @private
     */
    _accommodateObjectPath(object, path) {
        for (let property of path) {
            if (!object[property]) {
                object[property] = {}
            }
            object = object[property]
        }
        if (!object) {
            object = {}
        }
        return object
    }

    /**
     * Accommodates a path and puts the third argument at the end of that path
     * @param {Object} object
     * @param {Array&lt;String&gt;} path
     * @param stuffToInsert
     * @private
     */
    _accommodateInsideObject(object, path, stuffToInsert) {
        this._accommodateObjectPath(object, path.slice(0, -1))[path[path.length - 1]] = stuffToInsert
    }



    _iterateInObjectPath(object, path, callback) {
        for (let pathString of path) {
            let objectToPassToCallback = notFound;
            if (object.hasOwnProperty(pathString)) {
                object = object[pathString];
                objectToPassToCallback = object
            }
            callback(objectToPassToCallback)
        }
        return object
    }

    /**
     * Deep traverses the entire options structure
     * @param callback
     * @returns {*}
     * @private
     */
    _deepTraverseOptions(callback) {
        return this._deepTraverse(this.options, callback)
    }

    whenSettled() {
        if(Object.keys(this._updatesForNextTick).length || Object.keys(this._newOptionUpdates).length){
            return new Promise((resolve) =&gt; this.once(&apos;settled&apos;, resolve));
        }
        return Promise.resolve();
    }

    _handleResultingUpdates() {
        let triggerIndices = this._updatesForNextTick[OptionObserver.triggers];
        if (triggerIndices &amp;&amp; Object.keys(triggerIndices).length) {
            for (let index in triggerIndices) {
                this.triggerMethodForIndex(this.options, index);
                delete triggerIndices[index];
            }
            /* Reflush to take the changes made by the trigger methods into account */
            this.flushUpdates();
            delete this._updatesForNextTick[OptionObserver.triggers];
        }

        /* Currently, all renderables are &quot;one dimensional&quot;, they only have one name. That is why this is just a simple
         * over the first shallow level of this object
        */
        for (let renderableName in this._updatesForNextTick) {
            this.emit(&apos;needUpdate&apos;, renderableName)
        }
        this._updatesForNextTick = {};
        this.emit(&apos;settled&apos;);
        this._forbiddenUpdatesForNextTick = {};
    }


    /**
     *
     * @param newValue
     * @param oldValue
     * @param defaultOptionValue
     * @private
     */
    _processImmediateOptionReassignment({newValue, oldValue, defaultOptionValue}) {
        //This is kept a stub if there&apos;s more stuff needed to be added here. TODO Refactor function if not
        this._resetRemovedPropertiesIfNeeded(newValue, oldValue, defaultOptionValue)
    }

    /**
     * The most important function of the class. It traverses an ontouched level in the hierarchy of options
     * and acts accordingly
     *
     * @param nestedPropertyPath
     * @param defaultOption
     * @param newValue
     * @param propertyName
     * @param newValueParent
     * @param listenerTree
     * @param defaultOptionParent
     * @returns {*}
     * @private
     */
    _processNewOptionUpdates({nestedPropertyPath, defaultOption, newValue, propertyName, newValueParent, listenerTree, defaultOptionParent}) {

        let valueIsModelProperty = newValueParent instanceof Model &amp;&amp; typeof defaultOptionParent === &apos;function&apos;;

        let parentIsArray = Array.isArray(defaultOptionParent);
        if (!valueIsModelProperty &amp;&amp; !defaultOptionParent.hasOwnProperty(propertyName)) {
            if (parentIsArray) {
                defaultOption = defaultOptionParent[0]
            } else {
                this._throwError(`Assignment to undefined option: ${nestedPropertyPath.concat(propertyName).join(&apos;-&gt;&apos;)}`)
            }
        }

        if (typeof defaultOption === &apos;function&apos; &amp;&amp;
            ( (defaultOption.prototype instanceof Model || defaultOption === Model) ||
                (defaultOption.prototype instanceof PrioritisedArray || defaultOption === PrioritisedArray)
            )
        ) {
            if (!newValue || !(newValue instanceof defaultOption)) {
                this._throwError(`Failed to specify required: ${nestedPropertyPath.concat(propertyName).join(&apos;-&gt;&apos;)}.
          ${newValue} is not of type ${defaultOption.name}!`)
            }
        }


        let onChangeFunction = listenerTree[onOptionChange];
        let newValueIsInputOption = newValue instanceof InputOption;

        if (onChangeFunction !== undefined &amp;&amp; !newValueIsInputOption) {
            onChangeFunction(newValue)
        } else if (newValueIsInputOption) {
            let inputOptionObject = newValue;
            onChangeFunction = (innerValue) =&gt; inputOptionObject[changeValue](innerValue);
            listenerTree[onOptionChange] = onChangeFunction;
            newValue = inputOptionObject[unwrapValue](this, nestedPropertyPath.concat(propertyName));
        }

        if (valueIsModelProperty) {
            return
        }

        let valueToLinkTo;

        /* If set to something undefined, then set to the default option. Does not apply for default options */

        /*
         * If the new value is undefined, and the array has been emptied, then we assign this to the default option.
         * TODO: Come up with a more robust solution for default options of arrays */
        if (newValue === undefined &amp;&amp; (!parentIsArray || newValueParent.length === 0)) {
            newValue = defaultOption;
            if(onChangeFunction){
                onChangeFunction(newValue);
            }
            if (Utils.isPlainObject(newValue)) {
                valueToLinkTo = {};
                this._markAsOption(valueToLinkTo);
                valueToLinkTo[optionMetaData].isDefault = true
            }
        }

        if (valueToLinkTo === undefined) {
            valueToLinkTo = newValue
        }

        if (valueToLinkTo !== undefined) {
            this._setupOptionLink(newValueParent, propertyName, valueToLinkTo, nestedPropertyPath, listenerTree);
        }

        //TODO clean up code if needed (why is it even needed?)
        for (let property of Object.keys(defaultOptionParent)
            .filter((property) =&gt; Utils.isPlainObject(defaultOptionParent[property]) &amp;&amp; newValueParent[property] === undefined)
            ) {
            newValueParent[property] = {}
        }

        if (newValue instanceof Model) {
            this._handleNewModelUpdate(nestedPropertyPath, newValue, listenerTree, propertyName)
        }

        if (Array.isArray(newValue)) {
            this._setupArray(nestedPropertyPath, newValue, listenerTree, propertyName, defaultOption)
        }

        return newValue
    }

    /**
     *
     * @param nestedPropertyPath
     * @param newValue
     * @param listenerTree
     * @param outerPropertyName
     * @param defaultOption
     * @private
     */
    _setupArray(nestedPropertyPath, newValue, listenerTree, outerPropertyName, defaultOption) {
        if (!listenerTree[isArrayListener]) {
            this._throwError(`The parameter ${nestedPropertyPath.concat(outerPropertyName).join(&apos;-&gt;&apos;)} is not registered as an array in the listener tree.`)
        }

        if (ArrayObserver.isArrayObserved(newValue)) {
            //TODO Confirm that returning early is wished for
            return
        }
        /* Continue traversing down the array and update the rest like normal, using the array observer as a stepping stone*/
        let arrayObserver = new ArrayObserver(newValue, (index, value) =&gt; {
            /* copy the listener tree information */
            listenerTree[index] = listenerTree.value;
            //TODO This might be overkill since it&apos;s already handled in the flush function (Try removing code below and see if it still works)
            value = this._processNewOptionUpdates({
                defaultOptionParent: defaultOption,
                nestedPropertyPath: nestedPropertyPath.concat(outerPropertyName),
                defaultOption: defaultOption[index],
                newValueParent: newValue,
                newValue: value,
                propertyName: index,
                listenerTree: listenerTree[index]
            });

            this._deepTraverse(defaultOption[0], (innerNestedPropertyPath, defaultOptionParent, defaultOption, propertyName, [newValueParent, listenerTreeParent]) =&gt; {

                this._processNewOptionUpdates({
                    nestedPropertyPath: nestedPropertyPath.concat(outerPropertyName, index, innerNestedPropertyPath),
                    newValue: newValueParent[propertyName],
                    propertyName,
                    defaultOption,
                    defaultOptionParent,
                    listenerTree: listenerTreeParent[propertyName],
                    newValueParent
                })
            }, [value, listenerTree.value])
        });

        listenerTree[storedArrayObserver] = arrayObserver;

        //TODO utilize optimizations from partial updates (probably by implementing special events towards the view for this, aside from &apos;needUpdate&apos;)
        arrayObserver.on(&apos;mapCalled&apos;,
            (originalMapFunction, passedMapper) =&gt;
                //todo this isn&apos;t used. DOes it need to be here?
                this.emit(&apos;mapCalled&apos;, {nestedPropertyPath, listenerTree, originalMapFunction, passedMapper})
        );
        let onArrayChanged = ({index, newValue, oldValue}) =&gt; {
            this._markPropertyAsUpdated(nestedPropertyPath.concat(outerPropertyName), index, newValue, oldValue)
        };
        arrayObserver.on(&apos;replaced&apos;, onArrayChanged);
        arrayObserver.on(&apos;added&apos;, onArrayChanged);
        arrayObserver.on(&apos;removed&apos;, onArrayChanged);
        this._arrayObservers.push(arrayObserver)

    }

    _handleNewModelUpdate(nestedPropertyPath, newValue, listenerTree, key) {
        //TODO This implementation is a bit naive, won&apos;t work always (or in second thought, won&apos;t it?)
        let oldListenerStructureBase = this.accessObjectPath(this._modelListeners, [oldValue.constructor.name]);

        if (oldListenerStructureBase === notFound || !oldListenerStructureBase[oldValue.id]) {
            return this._setupModel(nestedPropertyPath, newValue, listenerTree, key).startListening()
        }

        let oldListenerStructure = oldListenerStructureBase[oldValue.id];

        if (oldListenerStructure.isListening()) {
            oldListenerStructure.stopListening();
            delete oldListenerStructureBase[oldValue.id];
            this._setupModel(nestedPropertyPath, newValue, listenerTree, key).startListening()
        }
    }

    _createListenerTree() {
        this._listenerTree = cloneDeepWith(this.defaultOptions, this._listenerTreeCloner.bind(this)) || {[listeners]: {}}
    }

    /**
     * Creates the listener tree
     * We are interested in a tree that is a copy of the defaultOptions and with a symbol [listeners] set to {} everywhere applicable
     * @param value
     * @param propertyName
     * @returns {*}
     * @private
     */
    _listenerTreeCloner(value, propertyName) {
        if ([listeners, isArrayListener].includes(propertyName)) {
            return value
        }
        let isPlainObject = Utils.isPlainObject(value), isArray = Array.isArray(value);
        /* If the object already has the listeners set*/
        if (typeof value === &apos;object&apos; &amp;&amp; value[listeners] &amp;&amp; !Object.keys(value).length) {
            return value
        }
        if (isPlainObject || isArray) {

            let listenersIfExists = value[listeners];
            if (!listenersIfExists) {
                let valueToClone = {...value, [listeners]: {}};
                if (isArray) {
                    valueToClone = {value: value[0] || {}, [listeners]: {}, [isArrayListener]: true}
                }

                return cloneDeepWith(valueToClone, this._listenerTreeCloner.bind(this));
            }
        } else {
            return {[listeners]: {}}
        }
    }


    _flushArrayObserverChanges() {
        for (let arrayObserver of this._arrayObservers) {
            arrayObserver.rebuild()
        }
    }

    _listenForModelUpdates(entryNames) {
        PrioritisedObject.setPropertyGetterSpy((model, propertyName) =&gt; {
            /* TODO handle the case where this can be undefined */
            let modelListenerOfType = this._modelListeners[model.constructor.name] || {};
            let modelListener = modelListenerOfType[model.id];
            if (!modelListenerOfType || !modelListener) {
                //TODO, instead of throwing an error, accommodate property in local listener
                return this._throwError(`Model when creating ${entryNames.join(&apos;&apos;)} not declared as a valid binding`);
            }
            let localListenerTree = modelListener.localListenerTree[propertyName];
            this._addToListenerTree(entryNames, localListenerTree);
            modelListener.startListening();
        })
    }

    _handleNewOptionUpdateLeaf(nestedPropertyPath, updateObject, propertyName, defaultOptionParent, listenerTree, optionObject) {
        let newValue = updateObject[newChanges],
            oldValue = updateObject[originalValue];
        let defaultOption = defaultOptionParent[propertyName];
        let innerListenerTree = listenerTree[propertyName];

        if (Utils.isPlainObject(defaultOptionParent)) {
            this._processImmediateOptionReassignment({
                newValue, oldValue, defaultOption
            })
        }

        this._processNewOptionUpdates({
            defaultOptionParent: defaultOptionParent,
            nestedPropertyPath,
            defaultOption,
            newValueParent: optionObject,
            newValue,
            propertyName,
            listenerTree: innerListenerTree
        });

        /* If the parent is a model or function, then no need to continue */
        if (!Utils.isPlainObject(defaultOption)) {
            return
        }

        let outerNestedPropertyPath = nestedPropertyPath.concat(propertyName);

        this._deepTraverseWithShallowArrays(defaultOption, (innerNestedPropertyPath, defaultOptionParent, defaultOption, propertyName, [listenerTreeParent, newValueParent]) =&gt; {
            this._processNewOptionUpdates({
                nestedPropertyPath: outerNestedPropertyPath.concat(innerNestedPropertyPath),
                defaultOption,
                newValueParent,
                newValue: newValueParent[propertyName],
                propertyName,
                defaultOptionParent,
                listenerTree: listenerTreeParent[propertyName]
            })
        }, [innerListenerTree, optionObject[propertyName]], [false, false])
    }


    static _instances = [];
    static _dirtyInstances = {};

    static _tickCount = 0;

    /**
     * Every tick, the changes are flushed in the options object. The _isFlushingUpdates flag gives an indication whether
     * the flushings are in progress or not
     *
     * @private
     */
    static _flushAllUpdates() {
        //TODO Add guards/errors for infinite updates here
        this._isFlushingUpdates = true;
        OptionObserver._tickCount++;
        /* Reset dirty instances, because we are going to traverse all instances anyways */
        OptionObserver._dirtyInstances = {};
        for (let optionObserver of OptionObserver._instances) {
            optionObserver.flushUpdates()
        }
        /* Flush dirty instances until there are no more dirty instances left */
        while (Object.keys(OptionObserver._dirtyInstances).length) {
            let dirtyInstances = {...OptionObserver._dirtyInstances};
            OptionObserver._dirtyInstances = {};
            for (let optionObserverID in dirtyInstances) {
                dirtyInstances[optionObserverID].flushUpdates()
            }
        }
        this._isFlushingUpdates = false;
    }

    static _registerNewInstance(newInstance) {
        this._instances.push(newInstance);
        newInstance[instanceIdentifier] = this._instances.length
    }

    static _markInstanceAsDirty(dirtyInstance) {
        OptionObserver._dirtyInstances[dirtyInstance[instanceIdentifier]] = dirtyInstance
    }
}

/* Flush updates, if they exist, every tick */
Timer.every(OptionObserver._flushAllUpdates);</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
